<!DOCTYPE HTML>


<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko">
  <head>
    <meta charset="utf-8"/>
    
    <link href="modules.html" rel="alternate" hreflang="en"/>
<link href="modules.fr.html" rel="alternate" hreflang="fr"/>
<link href="modules.ja.html" rel="alternate" hreflang="ja"/>
<link href="modules.ko.html" rel="alternate" hreflang="ko"/>
<link href="modules.zh.html" rel="alternate" hreflang="zh"/>

    
    <title>모듈 &#8211; OCaml</title>
    <link href="../../img/favicon32x32.ico?" rel="shortcut icon" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <link href="//fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css"/>
    
    <link href="../../css/bootstrap.css" rel="stylesheet" media="screen"/>
    <link href="../../css/bootstrap_mod.css" rel="stylesheet" media="screen"/>
    <link href="../../css/ocamlorg.css" rel="stylesheet" media="screen"/>
    
    
    <script src="../../js/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="../../" class="brand"><img src="../../img/colour-logo-white.svg" class="svg" alt="OCaml"/><img src="../../img/colour-logo-white.png" class="png" alt="OCaml"/></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="../../learn/">Learn</a></li>
              <li><a href="../../docs/">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Packages</a></li>
              <li><a href="../../community/">Community</a></li>
              <li><a href="../../community/planet/">News</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/modules.ko.md" title="Edit this page" class="edit-this-page pull-right"><span>Edit this page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input type="hidden" name="as_sitesearch" value="ocaml.org"/>
              <input placeholder="Search" class="search-query" name="q" type="text"/>
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="../../">Home</a><span class="divider"></span></li>
<li><a href="../../learn/">Learn</a><span class="divider"></span></li>
<li><a href="../../learn/tutorials/index.ko.html">OCaml튜토리얼</a><span class="divider"></span></li>
<li class="active">모듈</li>


    </ol>
    <ul class="translations">
      <li><a href="modules.html">en</a></li>
<li><a href="modules.fr.html">fr</a></li>
<li><a href="modules.ja.html">日本語</a></li>
<li class="active">한국어</li>
<li><a href="modules.zh.html">中文</a></li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contents</a></li>
          <ul><li><a href="#">기본 사용법</a>
</li><li><a href="#Interfaces-and-signatures">인터페이스와 시그너쳐 (Interfaces and signatures)</a>
</li><li><a href="#Abstract-types">추상 타입 (Abstract types)</a>
</li><li><a href="#Submodules">서브 모듈 (Submodules)</a>
<ul><li><a href="#Submodule-implementation">서브 모듈 구현 (Submodule implementation)</a>
</li><li><a href="#">서브모듈 인터페이스</a>
</li></ul>
</li><li><a href="#Functors">펑터 (Functors)</a>
<ul><li><a href="#">펑터는 무엇이며 왜 필요한가?</a>
</li><li><a href="#">기존의 펑터는 어떻게 쓰나?</a>
</li><li><a href="#">펑터는 어떻게 정의하나?</a>
</li></ul>
</li><li><a href="#">모듈의 실용적인 조작</a>
<ul><li><a href="#">모듈의 인터페이스를 표시하기</a>
</li><li><a href="#">모듈을 포함시키기</a>
</li></ul>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        

<h1 id="">모듈</h1>

<h2 id="">기본 사용법</h2>

<p>OCaml에서 모든 코드는 모듈 내에 들어 있다. 또한 자주 사용되지 않지만
파일 시스템의 디렉토리와 비슷하게, 모듈 자체가 다른 모듈의 서브 모듈이
될 수 있다.</p>
<p><code>amodule.ml</code>과 <code>bmodule.ml</code> 두 파일을 사용해 프로그램을 작성한다고 하면,
각 파일의 이름에 따라 <code>Amodule</code>, <code>Bmodule</code>라는 이름의 모듈이 자동으로
정의되며 각 모듈들은 해당 파일 내에 입력한 내용을 제공하게 된다.</p>
<p><code>amodule.ml</code> 파일의 내용은 다음과 같다:</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">&quot;Hello&quot;</span></code></pre>

<p><code>bmodule.ml</code>은 아래와 같다:</p>
<pre><code class="ocaml"><span class="ocaml-module">Amodule</span>.hello ()</code></pre>

<p>보통 파일들은 하나씩 컴파일 된다. 직접 해 보자.</p>
<pre class="shell"><code class="shell">ocamlopt -c amodule.ml
ocamlopt -c bmodule.ml
ocamlopt -o hello amodule.cmx bmodule.cmx</code></pre>

<p>자 이제 우리는 &quot;Hello&quot;를 인쇄하는 훌륭한 실행 파일이 생겼다. 위 코드에서
보이는 것 처럼 어떤 모듈에서 무엇인가에 접근하기 위해서는 (항상 대문자로
시작하는) 모듈의 이름 + 점(.) + 값, 타입 생성자 또는 해당 모듈이
제공하는 무엇인가의 이름을 사용한다.</p>
<p>표준 라이브러리부터 시작해 라이브러리들은 모듈들의 콜렉션을 제공한다.
예를 들어 <code>List.iter</code>는 <code>List</code> 모듈 내의 <code>iter</code> 함수를 지정한다.</p>
<p>자, 어떤 모듈을 자주 사용한다면, 그 모듈의 내용을 바로 접근하고 싶을
수도 있을 것이다. 이를 위해 <code>open</code> 지시자를 사용한다. 우리 예에서는
<code>bmodule.ml</code> 가 아래와 같이 쓰여질 수 있을 것이다:</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Amodule</span><span class="ocaml-prompt">;;</span><br/>hello ();;</code></pre>

<p>별개의 이야기 이지만, 사람들은 보기 싫은 &quot;;;&quot;를 피하려는 경향이 있기
때문에 아래와 같이 쓰는 것이 더욱 일반적이다:</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Amodule</span>
<span class="governing">let</span> () =
  hello ()</code></pre>

<p>어쨌건 <code>open</code>을 사용하거나 말거나는 개인적인 기호의 문제이다. 어떤
모듈들은 다른 모듈들에서도 사용되는 이름을 제공해, 이름이 겹칠 수도
있다. <code>List</code> 모듈이 이런 예이다. 일반적으로 우리는 <code>open List</code>라고 하지
않는다. <code>Printf</code>와 같은 다른 모듈들이 <code>printf</code>와 같이 충돌을 일으켜서는
안되는 이름을 제공하기 때문이다. <code>Printf.printf</code>를 반복해서 쓰지 않기
위해 <code>open Printf</code>을 파일 맨 앞에 쓰는 것이 훨씬 상식적이다.</p>
<p>우리가 언급한 내용을 보여주는 간단한 예제가 있다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">open</span> <span class="ocaml-module">Printf</span>
  <span class="governing">let </span><span class="ocaml-variable">my_data</span> = [ <span class="string">&quot;a&quot;</span>; <span class="string">&quot;beautiful&quot;</span>; <span class="string">&quot;day&quot;</span> ]
  <span class="governing">let</span> () = <span class="ocaml-module">List</span>.iter (<span class="keyword">fun</span> s -&gt; printf <span class="string">&quot;%s\n&quot;</span> s) my_data</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">a
beautiful
day
</span><span class="ocaml-stderr"></span>val my_data : string list = [&quot;a&quot;; &quot;beautiful&quot;; &quot;day&quot;]
</span></code></pre>

<h2 id="Interfaces-and-signatures">인터페이스와 시그너쳐 (Interfaces and signatures)</h2>

<p>모듈은 자신을 사용하는 다른 프로그램들에게 함수, 타입, 서브 모듈 등과
같은 여러가지를 제공할 수 있다. 특별한 지정이 없다면 모듈 내에서 정의된
모든 것은 외부에서 접근이 가능하다. 대체로 개인이 작성한 소규모
프로그램의 경우는 상관 없지만, 모듈이 내부적으로만 사용되는 함수들과
타입들이 아닌 단지 외부에 제공해야 할 것들만 외부로 제공하는 것이 더
나은 상황들이 많이 있다.</p>
<p>이를 위해 우리는 모듈의 구현(implementation)을 가려줄 수 있는 모듈
인터페이스 (module interface)를 정의해야 한다. 모듈이 .ml 파일내에
정의되는 것과 마찬가지로, 해당 모듈 인터페이스 또는 시그너쳐는 .mli
파일에 들어간다. 이 파일은 타입이 명시된 값(value) 등과 같은 것들을 담고
있다. <code>amodule.ml</code> 파일을 다시 작성해 보자:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">&quot;Hello&quot;</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val message : string = &quot;Hello&quot;
val hello : unit -&gt; unit = &lt;fun&gt;
</span></code></pre>

<p>위에 따라 <code>Amodule</code>은 아래의 인터페이스를 가진다:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">message</span> : string
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit</code></pre>

<p>다른 모듈은 <code>message</code> 값에 직접 접근할 필요가 없다고 해 보자. 제한된
인터페이스를 정의하여 이 값을 숨기고 싶다면, <code>amodule.mli</code> 파일은 다음과
같다:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="comment">(** Displays a greeting message. *)</span></code></pre>

<p>(.mli 파일을
<a href="../../releases/4.10/htmlman/ocamldoc.html">ocamldoc</a>에서
지원하는 포맷을 이용해 문서화 하는 습관을 들이는 것이 좋다.)</p>
<p>.mli 파일은 .ml 파일과 매칭하기 직전에 컴파일 되어야 한다. <code>ocamlc</code>를
사용해서 컴파일 할 수 있으며, .ml 파일을 <code>ocamlopt</code>를 사용해 네이티브
코드(native code)로 컴파일 할 때도 마찬가지다:</p>
<pre class="shell"><code class="shell">ocamlc -c amodule.mli
ocamlopt -c amodule.ml
...</code></pre>

<h2 id="Abstract-types">추상 타입 (Abstract types)</h2>

<p>타입 정의는 어떤가? 우리는 함수와 같은 값(역주: OCaml에서는 함수도
값이다는 것을 기억하기 바란다)들이 .mli 파일에서 이들의 이름, 타입을
함께 명기하여 익스포트 할 수 있는 것을 보았다. 예를 들어 다음과 같다.</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit</code></pre>

<p>하지만 모듈들은 종종 새로운 타입을 정의한다. 날짜를 표현하는 간단한
레코드 타입을 정의해보자:</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span> = { day : int;  month : int;  year : int }</code></pre>

<p>.mli 파일을 쓸 때는 다음의 네 가지 (두 가지가 아니라) 선택이 있다.</p>
<ol><li>시그너쳐에서 타입을 완전히 제외한다.</li><li>타입 정의를 시그너쳐로 Copy &amp; Paste 한다.</li><li>타입을 추상화한다: 오직 이름만 지정한다.</li><li>레코드 필드를 읽기 전용으로 만든다: <code>type date = private { ... }</code></li></ol>

<p>위에서 세번째 경우는 다음과 같은 코드가 될 수 있다:</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span></code></pre>

<p>여기서 모듈의 사용자들은 타입 <code>date</code>의 객체를 조작할 수 있지만, 레코드
내의 필드를 직접 접근하는 것은 불가능하다. 사용자들은 모듈이 제공하는
함수를 써야만 한다. 모듈이 날짜 생성, 두 날짜간의 차이 계산, 날수를
해수로 바꾸는 세개의 함수를 제공한다고 가정해보자:</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span>
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">create</span> : ?days:int -&gt; ?months:int -&gt; ?years:int -&gt; unit -&gt; date
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">sub</span> : date -&gt; date -&gt; date
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">years</span> : date -&gt; float</code></pre>

<p>요점은 오직 <code>create</code>, <code>sub</code> 함수를 통해서 <code>date</code> 레코드를 만들 수 있다는
것이다. 따라서 모듈의 사용자가 잘못된 레코드를 생성하는 것 자체가
불가능하다. 사실 우리의 구현이 레코드를 사용하고 있지만, 이를 레코드가
아닌 다른 자료 구조로 바꿀 수도 있으며, 이 변경이 모듈을 사용하는 다른
코드들에 어떤 문제도 일으키지 않는다는 것을 알 수 있다. 즉 어떤
라이브러리가 같은 인터페이스를 제공하는 한 자료 구조를 포함한 내부
구조가 바뀌더라도 외부의 모듈에서는 동일하게 사용할 수 있다는 것이다.</p>
<h2 id="Submodules">서브 모듈 (Submodules)</h2>

<h3 id="Submodule-implementation">서브 모듈 구현 (Submodule implementation)</h3>

<p>우리는 <code>example.ml</code>이 자동으로 <code>Example</code>라는 이름의 모듈이 된다는 것을
보았다. 모듈 시그너쳐는 가능한 넓은 범위에서 자동으로 만들어지거나,
<code>example.mli</code> 파일을 작성하여 제한할 수도 있다.</p>
<p>어떤 모듈은 파일 내에서 명시적으로 정의할 수 있다는 것도 이야기 하였다.
이것이 현재 모듈의 서브 모듈이 된다. 아래 <code>example.ml</code> 파일을 보자:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>= <span class="governing">struct</span>
  <span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">&quot;Hello&quot;</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message
<span class="governing">end</span>
<span class="governing">let</span> <span class="ocaml-function">goodbye</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">&quot;Goodbye&quot;</span>
<span class="governing">let</span> <span class="ocaml-function">hello_goodbye</span> <span class="ocaml-variable">() </span>=
  <span class="ocaml-module">Hello</span>.hello ();
  goodbye ()</code></pre>

<p>아래의 예에서 두 단계의 모듈이라는 것을 확인할 수 있다:</p>
<pre><code class="ocaml"><span class="governing">let</span> () =
  <span class="ocaml-module">Example</span>.<span class="ocaml-module">Hello</span>.hello ();
  <span class="ocaml-module">Example</span>.goodbye ()</code></pre>

<h3 id="">서브모듈 인터페이스</h3>

<p>서브모듈의 인터페이스 역시 제한할 수 있다. 이를 모듈 타입이라 한다.
<code>example.ml</code> 파일에서 이를 보자:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>: <span class="governing">sig</span>
 <span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="governing">end</span> = 
<span class="governing">struct</span>
  <span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">&quot;Hello&quot;</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message
<span class="governing">end</span>
  
<span class="comment">(* &#51060; &#51648;&#51216;&#50640;&#49436;, <span class="ocaml-module">Hello</span>.message&#45716; &#45908; &#51060;&#49345; &#51217;&#44540;&#51060; &#48520;&#44032;&#45733;&#54616;&#45796;. *)</span>
<span class="governing">let</span> <span class="ocaml-function">goodbye</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">&quot;Goodbye&quot;</span>
<span class="governing">let</span> <span class="ocaml-function">hello_goodbye</span> <span class="ocaml-variable">() </span>=
  <span class="ocaml-module">Hello</span>.hello ();
  goodbye ()</code></pre>

<p>위에서 <code>Hello</code> 모듈의 정의는 <code>hello.mli</code>/<code>hello.ml</code> 파일 쌍의 경우와
동등하다. 모든 내용을 하나의 코드 블럭에 쓰는 것은 우아하지 못하므로,
보통은 각 모듈 시그너쳐를 따로 정의하는 것을 선호한다:</p>
<pre><code class="ocaml"><span class="governing">module <span class="governing">type</span></span> <span class="ocaml-module">Hello_type</span> <span class="ocaml-variable"></span>= <span class="governing">sig</span>
 <span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="governing">end</span>
  
<span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>: <span class="ocaml-module">Hello_type</span> = <span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p><code>Hello_type</code> 는 지명된 모듈 타입이며(named module type), 다른 모듈
인터페이스를 정의하기 위해 재사용 될 수 있다.</p>
<p>비록 특정 경우에 서브모듈이 유용할 수 있지만, 진정한 효용은 functor와
함께할 때이다. 다음 섹션으로 넘어가보자.</p>
<h2 id="Functors">펑터 (Functors)</h2>

<p>펑터는 아마 Ocaml의 기능 중 가장 복잡한 것일 테지만, 성공적인 OCaml
프로그래머가 되기 위해 펑터를 광범위하게 써야할 필요는 없다. 사실,
아마도 펑터를 직접 정의할 일이 결코 없을테지만, 표준 라이브러리에서
펑터를 분명히 보게 될 것이다. 펑터는 Set과 Map 모듈을 사용하는 유일한
방법이지만, 사용 그 자체는 그다지 어렵지 않다. (역주: 용어 Functor의
한글 번역은 위키백과의
<a href="http://ko.wikipedia.org/wiki/%ED%8E%91%ED%84%B0">펑터</a>를
참조했다.)</p>
<h3 id="">펑터는 무엇이며 왜 필요한가?</h3>

<p>펑터는 다른 모듈에 의해 매개화되는(parametrized) 모듈이다. 함수가
인수(arguments)라는 다른 값(value)으로 매개화 되는 것과 같다.</p>
<p>기본적으로 OCaml에서 직접적으로 가능하지는 않지만, 펑터는 타입을 값으로
매개화 할 수 있게 해 준다. 예를들어 우리는 int n을 받아, 길이가 n인
배열에 대해서만 동작하는 배열 연산들의 콜렉션을 돌려주는 펑터를 정의할
수 있다. 만일 프로그래머가 실수로 이러한 펑터에 (역주: 원문에는
function이라 되어 있지만 맥락상 펑터가 맞는 것으로 보임) 보통의 배열을
넘긴다면, 컴파일 에러가 날 것이다. 만일 우리가 펑터를 사용하지 않고 표준
배열 타입을 사용한다면, 컴파일러는 에러를 검지하지 못할 것이고, 훨씬 더
나쁜 결과로 런타임 에러를 야기할 것이다.</p>
<h3 id="">기존의 펑터는 어떻게 쓰나?</h3>

<p>표준 라이브러리는 <code>Make</code> 펑터를 제공하는 <code>Set</code>를 정의한다. 이 펑터는 한
개의 인자를 받는데, 이 인자는 (최소한) 다음 두가지를 제공하는 모듈이다:
<code>t</code>로 지정하는 요소의 타입과 <code>compare</code>로 지정되는 비교 함수이다. 펑터의
요체는 동일한 비교 함수가 항상 사용되는 것을 보증해 주는 것이다.
프로그래머가 실수를 하는 경우에도.</p>
<p>예를들어 우리가 정수의 집합을 사용하기 원한다면, 다음과 같이 할 수 있다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">Int_set</span> <span class="ocaml-variable"></span>= <span class="ocaml-module">Set</span>.Make (<span class="governing">struct</span>
                               <span class="governing">type</span> <span class="type">t</span> = int
                               <span class="governing">let </span><span class="ocaml-variable">compare</span> = compare
                             <span class="governing">end</span>)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module Int_set :
  sig
    type elt = int
    type t
    val empty : t
    val is_empty : t -&gt; bool
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val singleton : elt -&gt; t
    val remove : elt -&gt; t -&gt; t
    val union : t -&gt; t -&gt; t
    val inter : t -&gt; t -&gt; t
    val disjoint : t -&gt; t -&gt; bool
    val diff : t -&gt; t -&gt; t
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val subset : t -&gt; t -&gt; bool
    val iter : (elt -&gt; unit) -&gt; t -&gt; unit
    val map : (elt -&gt; elt) -&gt; t -&gt; t
    val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a
    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool
    val exists : (elt -&gt; bool) -&gt; t -&gt; bool
    val filter : (elt -&gt; bool) -&gt; t -&gt; t
    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t
    val cardinal : t -&gt; int
    val elements : t -&gt; elt list
    val min_elt : t -&gt; elt
    val min_elt_opt : t -&gt; elt option
    val max_elt : t -&gt; elt
    val max_elt_opt : t -&gt; elt option
    val choose : t -&gt; elt
    val choose_opt : t -&gt; elt option
    val split : elt -&gt; t -&gt; t * bool * t
    val find : elt -&gt; t -&gt; elt
    val find_opt : elt -&gt; t -&gt; elt option
    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val of_list : elt list -&gt; t
    val to_seq_from : elt -&gt; t -&gt; elt Seq.t
    val to_seq : t -&gt; elt Seq.t
    val add_seq : elt Seq.t -&gt; t -&gt; t
    val of_seq : elt Seq.t -&gt; t
  end
</span></code></pre>

<p>문자열 집합의 경우, 표준 라이브러리가 타입 <code>t</code>와 함수 <code>compare</code>의
<code>String</code> 모듈을 제공하기 때문에 훨씬 쉽다. 주의 깊게 따라 왔다면, 문자열
집합을 조작하는 모듈을 어떻게 만드는지는 짐작했을 것이다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">String_set</span> <span class="ocaml-variable"></span>= <span class="ocaml-module">Set</span>.Make (String)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module String_set :
  sig
    type elt = String.t
    type t = Set.Make(String).t
    val empty : t
    val is_empty : t -&gt; bool
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val singleton : elt -&gt; t
    val remove : elt -&gt; t -&gt; t
    val union : t -&gt; t -&gt; t
    val inter : t -&gt; t -&gt; t
    val disjoint : t -&gt; t -&gt; bool
    val diff : t -&gt; t -&gt; t
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val subset : t -&gt; t -&gt; bool
    val iter : (elt -&gt; unit) -&gt; t -&gt; unit
    val map : (elt -&gt; elt) -&gt; t -&gt; t
    val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a
    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool
    val exists : (elt -&gt; bool) -&gt; t -&gt; bool
    val filter : (elt -&gt; bool) -&gt; t -&gt; t
    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t
    val cardinal : t -&gt; int
    val elements : t -&gt; elt list
    val min_elt : t -&gt; elt
    val min_elt_opt : t -&gt; elt option
    val max_elt : t -&gt; elt
    val max_elt_opt : t -&gt; elt option
    val choose : t -&gt; elt
    val choose_opt : t -&gt; elt option
    val split : elt -&gt; t -&gt; t * bool * t
    val find : elt -&gt; t -&gt; elt
    val find_opt : elt -&gt; t -&gt; elt option
    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val of_list : elt list -&gt; t
    val to_seq_from : elt -&gt; t -&gt; elt Seq.t
    val to_seq : t -&gt; elt Seq.t
    val add_seq : elt Seq.t -&gt; t -&gt; t
    val of_seq : elt Seq.t -&gt; t
  end
</span></code></pre>

<p>(괄호는 꼭 있어야 한다)</p>
<h3 id="">펑터는 어떻게 정의하나?</h3>

<p>하나의 인자를 가진 펑터는 다음과 같이 정의한다:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>= <span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p><code>X</code>는 인자로 넘겨질 모듈이고 <code>X_type</code>는 이 모듈의 시그너쳐 이며 꼭
필요하다.</p>
<p>반환되는 모듈의 시그너쳐 역시 다음 문법을 사용해 제한할 수 있다:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>: <span class="ocaml-module">Y_type</span> =
<span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p>또는 이를 .mli 파일에 지정할 수도 있다:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>: Y_type</code></pre>

<p>전반적으로 펑터의 문법은 터득하기 어렵다. 가장 좋은 방법은 표준
라이브러리의 <code>set.ml</code> 이나 <code>map.ml</code>의 소스 코드를 보는 것일 터이다.
마지막 주석: 펑터는 성능 향상이 아니라, 프로그래머가 정확한 프로그램을
작성하는 것을 돕기 위한 것이다. 펑터의 소스 코드에 대한 접근이 가능해야
하는 ocamldefun과 같은 디펑터라이저 (defunctorizer)를 사용하지 않는
경우에도 런타임 에러의 가능성은 있다.</p>
<h2 id="">모듈의 실용적인 조작</h2>

<h3 id="">모듈의 인터페이스를 표시하기</h3>

<p><code>ocaml</code> 톱레벨에서 <code>List</code>와 같은 기존 모듈의 내용을 표시하기 위해 아래의
트릭이 사용된다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">M</span> = <span class="ocaml-module">List</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module M = List
</span></code></pre>

<p>아니면, 대부분의 라이브러리에 대한 온라인 문서를 참조하거나 labltk
(OCaml용 Tk GUI)에 들어 있는 <code>ocamlbrowser</code>를 사용할 수 있다.</p>
<h3 id="">모듈을 포함시키기</h3>

<p>표준 <code>List</code> 모듈에서 필요한 어떤 함수가 빠져 있으며, 이 함수를 이 모듈의
일부로 만들고 싶다고 하자. 아래의 <code>extensions.ml</code>과 같은 파일을 통해
우리는 <code>include</code> 지시자로 같은 효과를 낼 수 있다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">List</span> <span class="ocaml-variable"></span>= <span class="governing">struct</span>
    <span class="governing">include</span> List
    <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">optmap</span> <span class="ocaml-variable">f </span>= <span class="keyword">function</span>
      | [] -&gt; []
      | hd :: tl -&gt;
         <span class="keyword">match</span> f hd <span class="keyword">with</span>
         | None -&gt; optmap f tl
         | Some x -&gt; x :: optmap f tl
  <span class="governing">end</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module List :
  sig
    type 'a t = 'a list = [] | (::) of 'a * 'a list
    val length : 'a list -&gt; int
    val compare_lengths : 'a list -&gt; 'b list -&gt; int
    val compare_length_with : 'a list -&gt; int -&gt; int
    val cons : 'a -&gt; 'a list -&gt; 'a list
    val hd : 'a list -&gt; 'a
    val tl : 'a list -&gt; 'a list
    val nth : 'a list -&gt; int -&gt; 'a
    val nth_opt : 'a list -&gt; int -&gt; 'a option
    val rev : 'a list -&gt; 'a list
    val init : int -&gt; (int -&gt; 'a) -&gt; 'a list
    val append : 'a list -&gt; 'a list -&gt; 'a list
    val rev_append : 'a list -&gt; 'a list -&gt; 'a list
    val concat : 'a list list -&gt; 'a list
    val flatten : 'a list list -&gt; 'a list
    val iter : ('a -&gt; unit) -&gt; 'a list -&gt; unit
    val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a list -&gt; unit
    val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
    val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a list -&gt; 'b list
    val rev_map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
    val filter_map : ('a -&gt; 'b option) -&gt; 'a list -&gt; 'b list
    val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a
    val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b
    val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit
    val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list
    val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list
    val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'c list -&gt; 'a
    val fold_right2 :
      ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c -&gt; 'c
    val for_all : ('a -&gt; bool) -&gt; 'a list -&gt; bool
    val exists : ('a -&gt; bool) -&gt; 'a list -&gt; bool
    val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool
    val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool
    val mem : 'a -&gt; 'a list -&gt; bool
    val memq : 'a -&gt; 'a list -&gt; bool
    val find : ('a -&gt; bool) -&gt; 'a list -&gt; 'a
    val find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option
    val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
    val find_all : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
    val partition : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list
    val assoc : 'a -&gt; ('a * 'b) list -&gt; 'b
    val assoc_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option
    val assq : 'a -&gt; ('a * 'b) list -&gt; 'b
    val assq_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option
    val mem_assoc : 'a -&gt; ('a * 'b) list -&gt; bool
    val mem_assq : 'a -&gt; ('a * 'b) list -&gt; bool
    val remove_assoc : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list
    val remove_assq : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list
    val split : ('a * 'b) list -&gt; 'a list * 'b list
    val combine : 'a list -&gt; 'b list -&gt; ('a * 'b) list
    val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list -&gt; 'a list
    val to_seq : 'a list -&gt; 'a Seq.t
    val of_seq : 'a Seq.t -&gt; 'a list
    val optmap : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t
  end
</span></code></pre>

<p>위 파일은 <code>Extensions.List</code>라는 새로운 모듈을 만드는데, 표준 <code>List</code>
모듈의 모든 내용과 함께 <code>optmap</code>라는 새로운 함수가 생겼다. 다른 파일에서
기본 <code>List</code> 모듈을 오버라이드(override)하기 위해 우리가 해야할 것은 단지
.ml 파일의 맨 처음에 <code>open Extensions</code>를 써 주는 것 뿐이다:</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Extensions</span>
...
<span class="ocaml-module">List</span>.optmap ...</code></pre>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	
<div class="column">
  <div class="entry">
    <h1><a href="../../learn/">Learn</a></h1>
    <ul>
      <li><a href="../../learn/taste.html">Code Examples</a></li>
      <li><a href="../../learn/tutorials/index.ko.html">Tutorials</a></li>
      <li><a href="../../learn/books.html">Books</a></li>
      <li><a href="../../learn/success.html">Success Stories</a></li>
      <li><a href="."></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../docs/">Documentation</a></h1>
    <ul>
      <li><a href="../../docs/install.html">Install</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manual</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Packages</a></li>
      <li><a href="../../releases/index.html">Compiler Releases</a></li>
      <li><a href="../../docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../community/">Community</a></h1>
    <ul>
      <li><a href="../../community/mailing_lists.html">Mailing Lists</a></li>
      <li><a href="../../meetings/">Meetings</a></li>
      <li><a href="../../community/planet/">News</a></li>
      <li><a href="../../community/support.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Bug Tracker</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Website</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/modules.ko.md" target="_blank">Edit this page</a></li>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Website Issues</a></li>
      <li><a href="../../about.html">About This Site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Find Us on GitHub</a></li>
      <li><a href="../../contributors.html">Credits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js" type="text/javascript"></script>

     

  </body>
</html>
