<!DOCTYPE HTML>


<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
  <head>
    <meta charset="utf-8"/>
    
    <link href="data_types_and_matching.html" rel="alternate" hreflang="en"/>
<link href="data_types_and_matching.fr.html" rel="alternate" hreflang="fr"/>
<link href="data_types_and_matching.it.html" rel="alternate" hreflang="it"/>
<link href="data_types_and_matching.ja.html" rel="alternate" hreflang="ja"/>
<link href="data_types_and_matching.zh.html" rel="alternate" hreflang="zh"/>

    
    <title>Types de données et filtrage de motif &#8211; OCaml</title>
    <link href="../../img/favicon32x32.ico?" rel="shortcut icon" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <link href="//fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css"/>
    
    <link href="../../css/bootstrap.css" rel="stylesheet" media="screen"/>
    <link href="../../css/bootstrap_mod.css" rel="stylesheet" media="screen"/>
    <link href="../../css/ocamlorg.css" rel="stylesheet" media="screen"/>
    
    
    <script src="../../js/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="../../index.fr.html" class="brand"><img src="../../img/colour-logo-white.svg" class="svg" alt="OCaml"/><img src="../../img/colour-logo-white.png" class="png" alt="OCaml"/></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="../../learn/index.fr.html">Apprendre</a></li>
              <li><a href="../../docs/">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Contributions</a></li>
              <li><a href="../../community/index.fr.html">Communauté</a></li>
              <li><a href="../../community/planet/">Nouvelles</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/data_types_and_matching.fr.md" title="Éditer cette page" class="edit-this-page pull-right"><span>Éditer cette page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input type="hidden" name="as_sitesearch" value="ocaml.org"/>
              <input placeholder="Rechercher" class="search-query" name="q" type="text"/>
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="../../">Home</a><span class="divider"></span></li>
<li><a href="../../learn/index.fr.html">Apprendre</a><span class="divider"></span></li>
<li><a href="../../learn/tutorials/index.fr.html">Tutoriel OCaml</a><span class="divider"></span></li>
<li class="active">Types de données et filtrage de motif</li>


    </ol>
    <ul class="translations">
      <li><a href="data_types_and_matching.html">en</a></li>
<li class="active">fr</li>
<li><a href="data_types_and_matching.it.html">it</a></li>
<li><a href="data_types_and_matching.ja.html">日本語</a></li>
<li><a href="data_types_and_matching.zh.html">中文</a></li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contenu</a></li>
          <ul><li><a href="#Listes-cha-n-es">Listes chaînées</a>
<ul><li><a href="#Le-type-d-39-une-liste-cha-n-e">Le type d&#39;une liste chaînée</a>
</li></ul>
</li><li><a href="#Structures">Structures</a>
</li><li><a href="#Variants-unions-marqu-es-et-num-rations">Variants (unions marquées et énumérations)</a>
<ul><li><a href="#Variants-r-cursifs-utilis-s-pour-les-arbres">Variants récursifs (utilisés pour les arbres)</a>
</li><li><a href="#Variants-param-tr-s">Variants paramétrés</a>
</li></ul>
</li><li><a href="#Listes-structures-et-variants-R-sum">Listes, structures et variants — Résumé</a>
</li><li><a href="#Filtrage-sur-les-structures-de-donn-es">Filtrage (sur les structures de données)</a>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        

<h1 id="Types-de-donn-es-et-filtrage-de-motif">Types de données et filtrage de motif</h1><h2 id="Listes-cha-n-es">Listes chaînées</h2><p>Comme en Perl, la notion de liste est directement supportée dans le
langage OCaml. En OCaml, tous les éléments d&#39;une liste doivent avoir le
même type. Une liste s&#39;écrit :</p>
<pre><code class="ocaml">[1; 2; 3]</code></pre>

<p>(Remarquez l&#39;utilisation de points-virgules, et non de virgules).</p>
<p><code>[]</code> est la liste vide.</p>
<p>Une liste a une <strong>tête</strong> (le premier élément) et une <strong>queue</strong> (les
autres éléments). La tête est un élément, la queue est une liste, donc
dans cet exemple la tête est l&#39;entier <code>1</code> alors que la queue est la
<em>liste</em> <code>[2; 3]</code>.</p>
<p>Une autre façon d&#39;écrire une liste est d&#39;utiliser l&#39;opérateur <strong>cons</strong>
<code>tête :: queue</code>. Toutes les expressions suivantes sont donc équivalentes :</p>
<pre><code class="ocaml">[1; 2; 3]
1 :: [2; 3]
1 :: 2 :: [3]
1 :: 2 :: 3 :: []</code></pre>

<p>Pourquoi mentionner l&#39;opérateur cons ? Et bien nous en aurons besoin un
peu plus bas, pour faire du <em>filtrage</em> (<em>pattern matching</em>) sur les
listes.</p>
<h3 id="Le-type-d-39-une-liste-cha-n-e">Le type d&#39;une liste chaînée</h3><p>Le type d&#39;une liste chaînée d&#39;entiers est <code>int list</code>, et plus
généralement le type d&#39;une liste chaînée de <code>toto</code>s est <code>toto list</code>.</p>
<p>Cela implique que tous les éléments d&#39;une liste chaînée doivent avoir le
même type; Il existe des types polymorphiques de listes (càd <code>&#39;a list</code>),
très utile pour écrire des fonctions manipulant des &quot;listes de n&#39;importe
quoi&quot; de manière générique. (Mais <code>&#39;a list</code> ne signifie pas que les
différents éléments d&#39;une liste peuvent avoir des types différents -
vous ne pouvez pas utiliser ce type polymorphique pour construire,
disons, une liste d&#39;entiers et de chaînes. Le sens de cette notation est
que les éléments de la liste peuvent être n&#39;importe quoi, mais tous &quot;du
même type de n&#39;importe quoi&quot;).</p>
<p>La fonction <code>length</code> définie dans le module standard de OCaml <code>List</code> en
est un bon exemple. Peu importe si une liste contient des entiers, des
chaînes, des objets ou des ratons-laveurs, la fonction <code>List.length</code>
peut être utilisée dessus. Le type de <code>List.length</code> est donc :</p>
<pre><code class="ocaml"><span class="ocaml-module">List</span>.length : 'a list -&gt; int</code></pre>

<h2 id="Structures">Structures</h2><p>Le C et le C++ proposent le concept simple de <code>struct</code>, abbréviation de
structure. En Java on peut utiliser des classes à la place, mais c&#39;est
beaucoup plus laborieux.</p>
<p>Considérons cette simple structure C :</p>
<pre class="C"><code class="C">struct paire_dentiers {
  int a, b;
};</code></pre><p>L&#39;équivalent le plus simple en OCaml sont les <strong>n-uplets</strong> (tuples),
comme la paire <code>(3, 4)</code> qui a pour type <code>int * int</code>. Contrairement aux
listes, les n-uplets peuvent contenir des éléments de types différents,
par exemple <code>(3, &quot;hello&quot;, &#39;x&#39;)</code> qui a pour type <code>int * string * char</code>.</p>
<p>Une manière légèrement plus complexe de traduire les struct C est
d&#39;utiliser un <strong>enregistrement</strong> (record). Les enregistrements, comme
les structs C, permettent de nommer leurs composants. Les composants des
n-uplets ne peuvent pas être nommées, et il faut se souvenir de l&#39;ordre
dans lequel ils apparaissent. Voici l&#39;enregistrement équivalent au
struct C ci-dessus :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">paire_dentiers</span> = { a : int; b : int }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type paire_dentiers = { a : int; b : int; }
</span></code></pre>

<p>Ceci définit le type, et voici comment <em>créer</em> effectivement des valeurs
de ce type :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">{ a=3; b=5 }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : paire_dentiers = {a = 3; b = 5}
</span></code></pre>

<p>Remarquez l&#39;utilisation de « : » dans la définition du type et de « = » pour
créer des valeurs de ce type.</p>
<p>Voici un exemple d&#39;utilisation des enregistrements, testé avec la boucle
interactive :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">paire_dentiers</span> = { a : int; b : int }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type paire_dentiers = { a : int; b : int; }
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">{a=3; b=5}</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : paire_dentiers = {a = 3; b = 5}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-error-loc">{a=3}</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: Some record fields are undefined: b
</span></code></pre>

<p>Donc OCaml refuse de laisser certains champs d&#39;un enregistrement non
définis.</p>
<h2 id="Variants-unions-marqu-es-et-num-rations">Variants (unions marquées et énumérations)</h2><p>Le concept d&#39;&quot;union marquée&quot; n&#39;existe pas vraiment en C, bien qu&#39;il
existe dans le compileur gcc. Voici comment on traduit d&#39;habitude une
union marquée en C:</p>
<pre class="C"><code class="C">struct foo {
  int type;
#define TYPE_INT 1
#define TYPE_PAIR_OF_INTS 2
#define TYPE_STRING 3
  union {
    int i;        // Si type == TYPE_INT.
    int pair[2];  // Si type == TYPE_PAIR_OF_INTS.
    char *str;    // Si type == TYPE_STRING.
  } u;
};</code></pre><p>Je suppose que nous avons tous déjà vu ça, et ce n&#39;est pas beau à voir.
Pour commencer, ce n&#39;est pas sûr : le programmeur peut accidentellement
utiliser, disons, le champ <code>u.i</code> quand c&#39;est en fait une chaîne qui est
stockée dans la structure. Ensuite, le compilateur ne peut pas
facilement vérifier que tous les types ont été considérés dans les
instructions <code>switch</code> (on peut utiliser un type <code>enum</code> pour se prémunir
contre ce problème précis). Le programmeur peut aussi oublier de
modifier le champ <code>type</code>, ce qui peut procurer des heures de jeu. Pour
finir, c&#39;est lourdingue.</p>
<p>Voici l&#39;équivalent en OCaml, élégant et concis:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">foo</span> =
    | Nothing
    | Int <span class="keyword">of</span> int
    | Pair <span class="keyword">of</span> int * int
    | String <span class="keyword">of</span> string</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type foo = Nothing | Int of int | Pair of int * int | String of string
</span></code></pre>

<p>Voilà pour la définition du type. Au début de chacune des sections,
séparées par des <code>|</code>, se trouve un constructeur. On peut les nommer
comme on veut, tant que leur nom commence par une capitale. Si un
constructeur peut être utilisé pour définir une valeur, il est suivi de
<code>of</code> et d&#39;un type, qui lui commence par une minuscule. Dans l&#39;exemple
ci-dessus, Nothing est utilisé comme une constante, alors que les autres
constructeurs définissent des valeurs.</p>
<p>Pour <em>créer</em> effectivement des valeurs de ce type, on peut écrire:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">Nothing</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : foo = Nothing
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">Int 3</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : foo = Int 3
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">Pair (4, 5)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : foo = Pair (4, 5)
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">String <span class="string">&quot;hello&quot;</span>
  <span class="comment">(* etc. *)</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : foo = String &quot;hello&quot;
</span></code></pre>

<p>Toutes ces expressions ont pour type <code>foo</code>.</p>
<p>Remarquez l&#39;utilisation de <code>of</code> dans la définition du type, qui ne se
retrouve PAS dans l&#39;écriture des valeurs de ce type.</p>
<p>Par extension, un simple <code>enum</code> C définit comme</p>
<pre><code class="ocaml">enum sign { positive, zero, negative };</code></pre>

<p>peut être traduit en OCaml par</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">sign</span> = Positive | Zero | Negative</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type sign = Positive | Zero | Negative
</span></code></pre>

<h3 id="Variants-r-cursifs-utilis-s-pour-les-arbres">Variants récursifs (utilisés pour les arbres)</h3><p>Les variants peuvent être récursifs, ce qui est souvent utilisé pour
définir des structures de données arborescentes. C&#39;est vraiment là que
se révèle l&#39;expressivité des langages fonctionnels :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">binary_tree</span> = Leaf <span class="keyword">of</span> int | Tree <span class="keyword">of</span> binary_tree * binary_tree</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type binary_tree = Leaf of int | Tree of binary_tree * binary_tree
</span></code></pre>

<p>Voilà quelques arbres binaires. Comme exercice, essayez de les dessiner
sur un bout de papier.</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">Leaf 3</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : binary_tree = Leaf 3
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">Tree (Leaf 3, Leaf 4)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : binary_tree = Tree (Leaf 3, Leaf 4)
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">Tree (Tree (Leaf 3, Leaf 4), Leaf 5)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : binary_tree = Tree (Tree (Leaf 3, Leaf 4), Leaf 5)
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">Tree (Tree (Leaf 3, Leaf 4), Tree (Tree (Leaf 3, Leaf 4), Leaf 5))</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : binary_tree =
Tree (Tree (Leaf 3, Leaf 4), Tree (Tree (Leaf 3, Leaf 4), Leaf 5))
</span></code></pre>

<h3 id="Variants-param-tr-s">Variants paramétrés</h3><p>L&#39;arbre binaire de la section précédente comporte un entier à chaque
feuille, mais comment faire pour décrire la <em>forme</em> de la structure de
données, en laissant le choix de ce qui doit être stocké dans chaque
feuille pour plus tard ? On peut utiliser un variant paramétré (ou
polymorphique), comme ceci :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">'a binary_tree</span> =
    | Leaf <span class="keyword">of</span> 'a
    | Tree <span class="keyword">of</span> 'a binary_tree * 'a binary_tree</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type 'a binary_tree = Leaf of 'a | Tree of 'a binary_tree * 'a binary_tree
</span></code></pre>

<p>C&#39;est le type général. Le type où chaque feuille stocke un entier
s&#39;appelle <code>int binary_tree</code>. De la même façon, le type où chaque feuille
stocke une chaîne s&#39;appelle <code>string binary_tree</code>. Pour l&#39;exemple suivant
nous allons taper des valeurs dans la boucle interactive, et laisser le
système d&#39;inférence de types nous donner leurs types :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">Leaf <span class="string">&quot;hello&quot;</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : string binary_tree = Leaf &quot;hello&quot;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">Leaf 3.0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : float binary_tree = Leaf 3.
</span></code></pre>

<p>Remarquez que le nom des types est à l&#39;envers (arbre binaire de
flottants → float binary_tree). C&#39;est comparable avec le nom des
types pour les listes, i.e. <code>int list</code>, etc.</p>
<p>En fait ce n&#39;est pas une coïncidence si <code>&#39;a list</code> est écrit lui aussi « à
l&#39;envers ». Les types listes ne sont que des types variants paramétrés,
avec une définition légèrement spéciale :</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">'a list</span> = [] | :: <span class="keyword">of</span> 'a * 'a list   <span class="comment">(* ceci n'est pas du vrai code OCaml *)</span></code></pre>

<p>En fait la définition ci-dessus ne compile pas. La définition suivante,
très similaire, compile correctement :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">'a list</span> = Nil | <span class="ocaml-error-loc">::</span> <span class="keyword">of</span> 'a * 'a list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: Syntax error
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-error-loc">Nil</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: Unbound constructor Nil
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">1 :: <span class="ocaml-error-loc">Nil</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: This variant expression is expected to have type int list
       The constructor Nil does not belong to type list
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">1 :: 2 :: <span class="ocaml-error-loc">Nil</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: This variant expression is expected to have type int list
       The constructor Nil does not belong to type list
</span></code></pre>

<p>Rappelez vous quand nous avons dit précédemment que les listes pouvaient
être écrites de deux façons, soit sous la forme syntaxiquement édulcorée
<code>[1; 2; 3]</code> ou sous la forme plus formelle <code>1 :: 2 :: 3 :: []</code>. En
regardant la définition de <code>&#39;a list</code> ci-dessus, l&#39;origine de la syntaxe
formelle devrait vous paraître plus clairement.</p>
<h2 id="Listes-structures-et-variants-R-sum">Listes, structures et variants — Résumé</h2><p>tableau en 3 colonnes avec nom et exemples de définition et de valeur.</p>
<pre class="text"><code class="text">list           int list                       [1; 2; 3]
tuple          int * string                   (3, &quot;hello&quot;)
record         type pair =                    { a = 3; b = &quot;hello&quot; }
                 { a: int; b: string }
variant        type foo =
                 | Int of int                 Int 3
                 | Pair of int * string
variant        type sign =
                 | Positive                   Positive
                 | Zero                       Zero
                 | Negative
parameterized  type &#39;a my_list =
variant          | Empty                      Cons (1, Cons (2, Empty))
                 | Cons of &#39;a * &#39;a my_list</code></pre>

<h2 id="Filtrage-sur-les-structures-de-donn-es">Filtrage (sur les structures de données)</h2><p>Une &quot;Fonctionnalité Vraiment Cool&quot;(tm) des langages fonctionnels est
leur capacité à démonter les structures de données et à effectuer du
filtrage (pattern matching) sur les données. Ce n&#39;est pas à proprement
parler une propriété &quot;fonctionnelle&quot; - on pourrait très bien imaginer
une nouvelle sorte de C qui offrirait ces mêmes services. Mais c&#39;est
tout de même une &quot;Fonctionnalité Vraiment Cool&quot;.</p>
<p>Commençons par un problème réel : je veux représenter des expressions
mathématiques simples comme <code>n * (x + y)</code> et effectuer les
multiplications symboliquement pour obtenir <code>n * x + n * y</code>.</p>
<p>Définissons un type pour ces expressions:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">expr</span> =
      | Plus <span class="keyword">of</span> expr * expr        <span class="comment">(* means a + b *)</span>
      | Minus <span class="keyword">of</span> expr * expr       <span class="comment">(* means a - b *)</span>
      | Times <span class="keyword">of</span> expr * expr       <span class="comment">(* means a * b *)</span>
      | Divide <span class="keyword">of</span> expr * expr      <span class="comment">(* means a / b *)</span>
      | Value <span class="keyword">of</span> string            <span class="comment">(* <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;n&quot;</span>, etc. *)</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type expr =
    Plus of expr * expr
  | Minus of expr * expr
  | Times of expr * expr
  | Divide of expr * expr
  | Value of string
</span></code></pre>

<p>L&#39;expression <code>n * (x + y)</code> s&#39;écrirait:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">Times (Value <span class="string">&quot;n&quot;</span>, Plus (Value <span class="string">&quot;x&quot;</span>, Value <span class="string">&quot;y&quot;</span>))</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : expr = Times (Value &quot;n&quot;, Plus (Value &quot;x&quot;, Value &quot;y&quot;))
</span></code></pre>

<p>Ecrivons une fonction qui affiche
<code>Times (Value &quot;n&quot;, Plus (Value &quot;x&quot;, Value &quot;y&quot;))</code> comme <code>n * (x + y)</code>. En
fait, je vais écrire deux fonctions, l&#39;une qui convertit une expression
en une jolie chaîne, et une autre qui l&#39;affiche (comme ça si j&#39;ai envie
d&#39;écrire la même chaîne dans un fichier, je n&#39;aurais pas à réécrire la
fonction en entier juste pour ça).</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">to_string</span> <span class="ocaml-variable">e </span>=
    <span class="keyword">match</span> e <span class="keyword">with</span>
    | Plus (left, right) -&gt;
       <span class="string">&quot;(&quot;</span> ^ to_string left ^ <span class="string">&quot; + &quot;</span> ^ to_string right ^ <span class="string">&quot;)&quot;</span>
    | Minus (left, right) -&gt;
       <span class="string">&quot;(&quot;</span> ^ to_string left ^ <span class="string">&quot; - &quot;</span> ^ to_string right ^ <span class="string">&quot;)&quot;</span>
    | Times (left, right) -&gt;
       <span class="string">&quot;(&quot;</span> ^ to_string left ^ <span class="string">&quot; * &quot;</span> ^ to_string right ^ <span class="string">&quot;)&quot;</span>
    | Divide (left, right) -&gt;
       <span class="string">&quot;(&quot;</span> ^ to_string left ^ <span class="string">&quot; / &quot;</span> ^ to_string right ^ <span class="string">&quot;)&quot;</span>
    | Value v -&gt; v</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val to_string : expr -&gt; string = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">print_expr</span> <span class="ocaml-variable">e </span>=
    print_endline (to_string e)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val print_expr : expr -&gt; unit = &lt;fun&gt;
</span></code></pre>

<p>(NB: L&#39;opérateur <code>^</code> sert à concaténer les chaînes.)</p>
<p>Voilà la fonction d&#39;affichage à l&#39;oeuvre:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">print_expr (Times (Value <span class="string">&quot;n&quot;</span>, Plus (Value <span class="string">&quot;x&quot;</span>, Value <span class="string">&quot;y&quot;</span>)))</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">(n * (x + y))
</span><span class="ocaml-stderr"></span>- : unit = ()
</span></code></pre>

<p>La forme générale pour le filtrage est:</p>
<pre><code class="ocaml"><span class="keyword">match</span> valeur <span class="keyword">with</span>
| motif    -&gt;  r&eacute;sultat
| motif    -&gt;  r&eacute;sultat
  ...</code></pre>

<p>Les motifs dans la colonne de gauche peuvent être simples, comme dans la
fonction <code>to_string</code> ci-dessus, ou plus complexe et imbriqués. L&#39;exemple
suivant est notre fonction de distribution symbolique de la
multiplication des expressions de la forme <code>n * (x + y)</code> ou
<code>(x + y) * n</code>, et pour cela on va utiliser un motif imbriqué :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">multiply_out</span> <span class="ocaml-variable">e </span>=
    <span class="keyword">match</span> e <span class="keyword">with</span>
    | Times (e1, Plus (e2, e3)) -&gt;
       Plus (Times (multiply_out e1, multiply_out e2),
             Times (multiply_out e1, multiply_out e3))
    | Times (Plus (e1, e2), e3) -&gt;
       Plus (Times (multiply_out e1, multiply_out e3),
             Times (multiply_out e2, multiply_out e3))
    | Plus (left, right) -&gt;
       Plus (multiply_out left, multiply_out right)
    | Minus (left, right) -&gt;
       Minus (multiply_out left, multiply_out right)
    | Times (left, right) -&gt;
       Times (multiply_out left, multiply_out right)
    | Divide (left, right) -&gt;
       Divide (multiply_out left, multiply_out right)
    | Value v -&gt; Value v</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val multiply_out : expr -&gt; expr = &lt;fun&gt;
</span></code></pre>

<p>La voilà en action:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">print_expr (multiply_out (Times (Value <span class="string">&quot;n&quot;</span>, Plus (Value <span class="string">&quot;x&quot;</span>, Value <span class="string">&quot;y&quot;</span>))))</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">((n * x) + (n * y))
</span><span class="ocaml-stderr"></span>- : unit = ()
</span></code></pre>

<p>Comment est-ce que marche la fonction <code>multiply_out</code> ? L&#39;essentiel se
trouve dans les deux premiers motifs. Le premier est
<code>Times (e1, Plus (e2, e3))</code> qui filtre les expressions de la forme
<code>e1 * (e2 + e3)</code>. Regardez la colonne de droite en face de ce motif, et
assurez vous que son contenu équivaut à <code>(e1 * e2) + (e1 * e3)</code>.</p>
<p>Le second motif fait la même chose pour les expressions de la forme
<code>(e1 + e2) * e3</code>.</p>
<p>Les autres motifs ne modifient pas la forme de l&#39;expression, mais font
le travail nécessaire d&#39;appeler la fonction <code>multiply_out</code> récursivement
sur leurs sous-expressions. Cela garantit que toutes les
sous-expressions de l&#39;expression sont correctement transformées. (Si
vous n&#39;étiez concernés que par la transformation de l&#39;expression la plus
externe, tous ces motifs auraient pu être remplacés par une simple règle
<code>e -&gt; e</code>).</p>
<p>Est-ce que l&#39;on peut effectuer l&#39;opération inverse (càd factoriser au
lieu de distribuer) ? Bien sûr ! (Mais c&#39;est un peu plus compliqué...).
La version suivante ne marche que pour l&#39;expression la plus externe.
Vous pourriez certainement l&#39;améliorer pour gérer tous les niveaux de
sous-expressions, et des cas plus complexes :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">factorize</span> <span class="ocaml-variable">e </span>=
    <span class="keyword">match</span> e <span class="keyword">with</span>
    | Plus (Times (e1, e2), Times (e3, e4)) when e1 = e3 -&gt;
       Times (e1, Plus (e2, e4))
    | Plus (Times (e1, e2), Times (e3, e4)) when e2 = e4 -&gt;
       Times (Plus (e1, e3), e4)
    | e -&gt; e</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val factorize : expr -&gt; expr = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">factorize (Plus (Times (Value <span class="string">&quot;n&quot;</span>, Value <span class="string">&quot;x&quot;</span>),
                   Times (Value <span class="string">&quot;n&quot;</span>, Value <span class="string">&quot;y&quot;</span>)))</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : expr = Times (Value &quot;n&quot;, Plus (Value &quot;x&quot;, Value &quot;y&quot;))
</span></code></pre>

<p>La fonction de factorisation ci-dessus introduit une paire de nouvelles
fonctionnalités. Vous pouvez ajouter ce qui s&#39;appelle une <strong>garde</strong> à
chaque motif. Une garde est une condition précédée de <code>when</code>, et qui
signifie que le filtrage n&#39;est fructueux que si le motif correspond <em>et</em>
la condition après la clause <code>when</code> est satisfaite.</p>
<pre><code class="ocaml"><span class="keyword">match</span> valeur <span class="keyword">with</span>
  motif      [ when condition ]   -&gt;  r&eacute;sultat
  motif      [ when condition ]   -&gt;  r&eacute;sultat
    ...</code></pre>

<p>La seconde fonctionalité est l&#39;opérateur <code>=</code> qui teste l&#39;&quot;égalité
structurelle&quot; de deux expressions. Cela signifie qu&#39;il descend
récursivement dans chacune de deux expressions pour vérifier qu&#39;elles
sont identiques à tous les niveaux.</p>
<p>OCaml est capable de vérifier au moment de la compilation que tous les
cas sont couverts par vos motifs. J&#39;ai modifié la définition du
<code>type expr</code> précédent pour y ajouter le constructeur <code>Product</code> :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">expr</span> = Plus <span class="keyword">of</span> expr * expr      <span class="comment">(* means a + b *)</span>
            | Minus <span class="keyword">of</span> expr * expr     <span class="comment">(* means a - b *)</span>
            | Times <span class="keyword">of</span> expr * expr     <span class="comment">(* means a * b *)</span>
            | Divide <span class="keyword">of</span> expr * expr    <span class="comment">(* means a / b *)</span>
            | Product <span class="keyword">of</span> expr list     <span class="comment">(* means a * b * c * ... *)</span>
            | Value <span class="keyword">of</span> string          <span class="comment">(* <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;n&quot;</span>, etc. *)</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type expr =
    Plus of expr * expr
  | Minus of expr * expr
  | Times of expr * expr
  | Divide of expr * expr
  | Product of expr list
  | Value of string
</span></code></pre>

<p>J&#39;ai ensuite recompilé la fonction <code>to_string</code> sans modifications. OCaml
a renvoyé l&#39;avertissement suivant :</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">le<span class="ocaml-error-loc">t rec</span></span></span><span class="ocaml-error-loc"> </span><span class="ocaml-function"><span class="ocaml-error-loc">to_string</span></span><span class="ocaml-error-loc"> </span><span class="ocaml-variable"><span class="ocaml-error-loc">e </span></span><span class="ocaml-error-loc">=
    </span><span class="keyword"><span class="ocaml-error-loc">match</span></span><span class="ocaml-error-loc"> e </span><span class="keyword"><span class="ocaml-error-loc">with</span></span><span class="ocaml-error-loc">
    | Plus (left, right) -&gt;
       </span><span class="string"><span class="ocaml-error-loc">&quot;(&quot;</span></span><span class="ocaml-error-loc"> ^ to_string left ^ </span><span class="string"><span class="ocaml-error-loc">&quot; + &quot;</span></span><span class="ocaml-error-loc"> ^ to_string right ^ </span><span class="string"><span class="ocaml-error-loc">&quot;)&quot;</span></span><span class="ocaml-error-loc">
    | Minus (left, right) -&gt;
       </span><span class="string"><span class="ocaml-error-loc">&quot;(&quot;</span></span><span class="ocaml-error-loc"> ^ to_string left ^ </span><span class="string"><span class="ocaml-error-loc">&quot; - &quot;</span></span><span class="ocaml-error-loc"> ^ to_string right ^ </span><span class="string"><span class="ocaml-error-loc">&quot;)&quot;</span></span><span class="ocaml-error-loc">
    | Times (left, right) -&gt;
       </span><span class="string"><span class="ocaml-error-loc">&quot;(&quot;</span></span><span class="ocaml-error-loc"> ^ to_string left ^ </span><span class="string"><span class="ocaml-error-loc">&quot; * &quot;</span></span><span class="ocaml-error-loc"> ^ to_string right ^ </span><span class="string"><span class="ocaml-error-loc">&quot;)&quot;</span></span><span class="ocaml-error-loc">
    | Divide (left, right) -&gt;
       </span><span class="string"><span class="ocaml-error-loc">&quot;(&quot;</span></span><span class="ocaml-error-loc"> ^ to_string left ^ </span><span class="string"><span class="ocaml-error-loc">&quot; / &quot;</span></span><span class="ocaml-error-loc"> ^ to_string right </span>^ <span class="string">&quot;)&quot;</span>
    | Value v -&gt; v</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr">Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Product _
</span>val to_string : expr -&gt; string = &lt;fun&gt;
</span></code></pre>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	
<div class="column">
  <div class="entry">
    <h1><a href="../../learn/index.fr.html">Apprendre</a></h1>
    <ul>
      <li><a href="../../learn/taste.fr.html">Exemples de code</a></li>
      <li><a href="../../learn/tutorials/index.fr.html">Tutoriels</a></li>
      <li><a href="../../learn/books.html">Livres</a></li>
      <li><a href="../../learn/success.fr.html">Cas d'usage</a></li>
      <li><a href="."></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../docs/">Documentation</a></h1>
    <ul>
      <li><a href="../../docs/install.fr.html">Installer OCaml</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manuel</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Contributions</a></li>
      <li><a href="../../releases/index.fr.html">Compiler Releases</a></li>
      <li><a href="../../docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../community/index.fr.html">Communauté</a></h1>
    <ul>
      <li><a href="../../community/mailing_lists.fr.html">Lieux de discussion</a></li>
      <li><a href="../../meetings/index.fr.html">Rencontres</a></li>
      <li><a href="../../community/planet/">Nouvelles</a></li>
      <li><a href="../../community/support.fr.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Signaler un bug d'OCaml</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Site Web</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/data_types_and_matching.fr.md" target="_blank">Éditer cette page</a></li>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Problèmes du site Web</a></li>
      <li><a href="../../about.fr.html">À propos de ce site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Dépôt GitHub</a></li>
      <li><a href="../../contributors.fr.html">Crédits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js" type="text/javascript"></script>

     

  </body>
</html>
