<!DOCTYPE HTML>


<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
  <head>
    <meta charset="utf-8"/>
    
    <link href="if_statements_loops_and_recursion.html" rel="alternate" hreflang="en"/>
<link href="if_statements_loops_and_recursion.fr.html" rel="alternate" hreflang="fr"/>
<link href="if_statements_loops_and_recursion.it.html" rel="alternate" hreflang="it"/>
<link href="if_statements_loops_and_recursion.ja.html" rel="alternate" hreflang="ja"/>
<link href="if_statements_loops_and_recursion.ko.html" rel="alternate" hreflang="ko"/>
<link href="if_statements_loops_and_recursion.zh.html" rel="alternate" hreflang="zh"/>

    
    <title>If语句，循环和递归 &#8211; OCaml</title>
    <link href="../../img/favicon32x32.ico?" rel="shortcut icon" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <link href="//fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css"/>
    
    <link href="../../css/bootstrap.css" rel="stylesheet" media="screen"/>
    <link href="../../css/bootstrap_mod.css" rel="stylesheet" media="screen"/>
    <link href="../../css/ocamlorg.css" rel="stylesheet" media="screen"/>
    
    
    <script src="../../js/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="../../" class="brand"><img src="../../img/colour-logo-white.svg" class="svg" alt="OCaml"/><img src="../../img/colour-logo-white.png" class="png" alt="OCaml"/></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="../../learn/">Learn</a></li>
              <li><a href="../../docs/">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Packages</a></li>
              <li><a href="../../community/">Community</a></li>
              <li><a href="../../community/planet/">News</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/if_statements_loops_and_recursion.zh.md" title="Edit this page" class="edit-this-page pull-right"><span>Edit this page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input type="hidden" name="as_sitesearch" value="ocaml.org"/>
              <input placeholder="Search" class="search-query" name="q" type="text"/>
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="../../">Home</a><span class="divider"></span></li>
<li><a href="../../learn/">Learn</a><span class="divider"></span></li>
<li><a href="../../learn/tutorials/index.zh.html">OCaml教程</a><span class="divider"></span></li>
<li class="active">If语句，循环和递归</li>


    </ol>
    <ul class="translations">
      <li><a href="if_statements_loops_and_recursion.html">en</a></li>
<li><a href="if_statements_loops_and_recursion.fr.html">fr</a></li>
<li><a href="if_statements_loops_and_recursion.it.html">it</a></li>
<li><a href="if_statements_loops_and_recursion.ja.html">日本語</a></li>
<li><a href="if_statements_loops_and_recursion.ko.html">한국어</a></li>
<li class="active">中文</li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contents</a></li>
          <ul><li><a href="#if-if">if语句 (实际上是if表达式)</a>
</li><li><a href="#begin-end">用 begin ... end</a>
</li><li><a href="#For-while">For 循环和 while 循环</a>
</li><li><a href="#">迭代链表</a>
</li><li><a href="#">迭代字符串</a>
</li><li><a href="#">递归</a>
<ul><li><a href="#">方法一</a>
</li><li><a href="#">方法二</a>
</li><li><a href="#">方法三</a>
</li><li><a href="#">附录</a>
</li><li><a href="#">递归例子：链表中最大的元素</a>
</li><li><a href="#">尾递归</a>
</li></ul>
</li><li><a href="#records">可变 records, 引用和数组</a>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        

<h1 id="If">If语句，循环和递归</h1>

<h2 id="if-if">if语句 (实际上是if表达式)</h2><p>OCaml有两种if语句：</p>
<pre><code class="ocaml"><span class="keyword">if</span> boolean-condition <span class="keyword">then</span> expression
  
<span class="keyword">if</span> boolean-condition <span class="keyword">then</span> expression <span class="keyword">else</span> other-expression</code></pre>

<p>不同于传统的语言，if语句是表达式。它们更类似于C类语言中的三元操作符<code>?:</code>
而不是你所熟悉的if语句。</p>
<p>下面是if语句的简单例子：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">max</span> <span class="ocaml-variable">a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> a <span class="keyword">else</span> b</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val max : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
</span></code></pre>

<p>如果你把上面的定义打入OCaml的toplevel，你会发现OCaml会把这个函数定义成多态的：</p>
<pre><code class="ocaml">max : 'a -&gt; 'a -&gt; 'a</code></pre>

<p>而确实OCaml也允许你把max应用到不同的类型：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">max 3 5</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 5
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">max 3.5 13.0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : float = 13.
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">max <span class="string">&quot;a&quot;</span> <span class="string">&quot;b&quot;</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : string = &quot;b&quot;
</span></code></pre>

<p>这是因为<code>&gt;</code>是多态的。它可以比较所有类型，包括对象（按位比较）。</p>
<p>[`Pervasives` 模块已经为你定义了`max`。]</p>
<p>让我们来仔细看看if语句。下面是<code>range</code>函数，你应该结合递归函数，链表，
if语句的知识来看看它到底在干些什么：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> []
    <span class="keyword">else</span> a :: range (a+1) b</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>让我们来验证一下一些典型的调用。当<code>a &gt; b</code>时，如<code>range 11 10</code>，应该返回<code>[]</code>，
而确实如此。</p>
<p>那<code>range 10 10</code>呢？因为<code>10 &gt; 10</code>为假，因此<code>else</code>部分被求值，也就是 <code>10 :: (range 11 10)</code>
（我加了括号让求值顺序更加清晰）。由于我们已经知道<code>range 11 10</code> = <code>[]</code>，因此，
结果就是<code>[ 10 ]</code>。</p>
<p>让我们再来看看 <code>range 9 10</code>：</p>
<pre><code class="ocaml">range 9 10
&rarr; 9 :: (range 10 10)
&rarr; 9 :: [ 10 ]
&rarr; [9; 10]</code></pre>

<p><code>range 1 10</code> 的结果显然就是
<code>[ 1; 2; 3; 4; 5; 6; 7; 8; 9; 10 ]</code>。</p>
<p>我们看到的是简单的递归结果。函数式编程可以说比起循环更倾向于递归，
不过请允许我跳过一下，在这一章的最后才再讨论递归多一些。</p>
<p>让我们回到if语句。下面这个函数干的什么事情?</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">x y </span>=
    x + <span class="keyword">if</span> y &gt; 0 <span class="keyword">then</span> y <span class="keyword">else</span> 0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val f : int -&gt; int -&gt; int = &lt;fun&gt;
</span></code></pre>

<p>提示：在if语句的周围加上括号。它就像一个<a href="https://en.wikipedia.org/wiki/Diode#Current.E2.80.93voltage_characteristic">二极管</a>.
一样截断<code>y</code>。</p>
<p><code>Pervasives</code>中的<code>abs</code>函数如下定义：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">abs</span> <span class="ocaml-variable">x </span>=
    <span class="keyword">if</span> x &gt;= 0 <span class="keyword">then</span> x <span class="keyword">else</span> -x</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val abs : int -&gt; int = &lt;fun&gt;
</span></code></pre>

<p>在 <code>Pervasives</code> 中的 <code>string_of_float</code> 函数也有一些复杂嵌套的if表达式：</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">string_of_float</span> <span class="ocaml-variable">f </span>=
  <span class="governing">let </span><span class="ocaml-variable">s</span> = format_float <span class="string">&quot;%.12g&quot;</span> f <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">l</span> = string_length s <span class="governing">in</span>
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">i </span>=
    <span class="keyword">if</span> i &gt;= l <span class="keyword">then</span> s ^ <span class="string">&quot;.&quot;</span>
    <span class="keyword">else</span> <span class="keyword">if</span> s.[i] = <span class="string">'.'</span> || s.[i] = <span class="string">'e'</span> <span class="keyword">then</span> s
    <span class="keyword">else</span> loop (i+1) <span class="governing">in</span>
  loop 0</code></pre>

<p>让我们来验证一下这个函数。如果 <code>f</code> = 12.34, 那么 <code>s</code> = &quot;12.34&quot; 并且 <code>l</code> = 5. 让后我们以<code>i</code> = 0 调用 <code>loop</code>。</p>
<p><code>i</code> 小于 <code>l</code>, 而且 <code>s.[i]</code> (<code>s</code>的第i个字母) 不是小数点或者 <code>&#39;e&#39;</code>. 所以
<code>loop (i+1)</code> 被调用，也就是 <code>loop 1</code>。</p>
<p>然后继续调用 <code>loop 2</code>。</p>
<p>当 <code>i</code> = 2时， <code>s.[i]</code> 是一个小数点（原来的字符串是<code>s</code> = &quot;12.34&quot;）。
所以马上返回<code>s</code>，这个函数<code>string_of_float</code> 返回了 &quot;12.34&quot;。</p>
<p>那这个<code>loop</code>干了什么？实际上它检查<code>format_float</code>返回的字符串是否包含一个小数点或者<code>&#39;e&#39;</code>。
如果我们调用<code>string_of_float 12.0</code>， <code>format_float</code>会返回&quot;12&quot;，但是 <code>string_of_float</code> 必须返回 &quot;12.&quot; 或者 &quot;12.0&quot;
（因为OCaml中的浮点数必须包含小数点来与整数区分）。因此要做这个检查。</p>
<p>这里递归的奇怪用法几乎是可以肯定是比较迅速的。虽然OCaml支持for循环，但是我们将看见
for循环的限制使得它不能在这里派上用场。下面是个更直接的实现方式，但它
的效率几乎是上面的1/2：</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">string_of_float</span> <span class="ocaml-variable">f </span>=
  <span class="governing">let </span><span class="ocaml-variable">s</span> = format_float <span class="string">&quot;%.12g&quot;</span> f <span class="governing">in</span>
  <span class="keyword">if</span> <span class="ocaml-module">String</span>.contains s <span class="string">'.'</span> || <span class="ocaml-module">String</span>.contains s <span class="string">'e'</span>
  <span class="keyword">then</span> s
  <span class="keyword">else</span> s ^ <span class="string">&quot;.&quot;</span></code></pre>

<h2 id="begin-end">用 begin ... end</h2><p>下面是 lablgtk 中的一段代码:</p>
<pre><code class="ocaml"><span class="keyword">if</span> <span class="ocaml-module">GtkBase</span>.<span class="ocaml-module">Object</span>.is_a obj cls <span class="keyword">then</span>
  <span class="keyword">fun</span> _ -&gt; f obj
<span class="keyword">else</span> <span class="governing">begin</span>
  eprintf <span class="string">&quot;Glade-warning: %s expects a %s argument.\n&quot;</span> name cls;
  <span class="keyword">raise</span> Not_found
<span class="governing">end</span></code></pre>

<p><code>begin</code> 和 <code>end</code> 是表示开闭括号的 <strong>语法糖</strong>。在上面的例子，它们的作用是把<code>else</code>语句
里的两个式子组合到一起。如果作者写成如下的形式：</p>
<pre><code class="ocaml"><span class="keyword">if</span> <span class="ocaml-module">GtkBase</span>.<span class="ocaml-module">Object</span>.is_a obj cls <span class="keyword">then</span>
  <span class="keyword">fun</span> _ -&gt; f obj
<span class="keyword">else</span>
  eprintf <span class="string">&quot;Glade-warning: %s expects a %s argument.\n&quot;</span> name cls;
  <span class="keyword">raise</span> Not_found</code></pre>

<p>如果给上面的表达式加上括号：</p>
<pre><code class="ocaml">(<span class="keyword">if</span> <span class="ocaml-module">GtkBase</span>.<span class="ocaml-module">Object</span>.is_a obj cls <span class="keyword">then</span>
   <span class="keyword">fun</span> _ -&gt; f obj
 <span class="keyword">else</span>
   eprintf <span class="string">&quot;Glade-warning: %s expects a %s argument.\n&quot;</span> name cls
);
<span class="keyword">raise</span> Not_found</code></pre>

<p>完全就不是你想表达的那个意思。所以用 <code>begin</code> 和 <code>end</code> 来组合
 <code>then</code> 或者 <code>else</code> 中的多个语句是必需的。你也可以用括号 <code>( ... )</code> 来表示这个关系
（我更喜欢括号，因为我觉得Pascal比较<strong>恶心</strong>）。下面有两个简单例子：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="keyword">if</span> 1 = 0 <span class="keyword">then</span>
      print_endline <span class="string">&quot;THEN&quot;</span>
    <span class="keyword">else</span> <span class="governing">begin</span>
      print_endline <span class="string">&quot;ELSE&quot;</span>;
      <span class="keyword">failwith</span> <span class="string">&quot;<span class="keyword">else</span> clause&quot;</span>
    <span class="governing">end</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">ELSE
</span><span class="ocaml-stderr"></span>Exception: Failure &quot;else clause&quot;.
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="keyword">if</span> 1 = 0 <span class="keyword">then</span>
      print_endline <span class="string">&quot;THEN&quot;</span>
    <span class="keyword">else</span> (
      print_endline <span class="string">&quot;ELSE&quot;</span>;
      <span class="keyword">failwith</span> <span class="string">&quot;<span class="keyword">else</span> clause&quot;</span>
    )</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">ELSE
</span><span class="ocaml-stderr"></span>Exception: Failure &quot;else clause&quot;.
</span></code></pre>

<h2 id="For-while">For 循环和 while 循环</h2><p>OCaml 支持一种比较受限制的 <code>for</code> 循环：</p>
<pre><code class="ocaml"><span class="keyword">for</span> variable = start_value <span class="keyword">to</span> end_value <span class="keyword">do</span>
  expression
<span class="keyword">done</span>
  
<span class="keyword">for</span> variable = start_value <span class="keyword">downto</span> end_value <span class="keyword">do</span>
  expression
<span class="keyword">done</span></code></pre>

<p>下面是 lablgtk 中的例子：</p>
<pre><code class="ocaml"><span class="keyword">for</span> i = 1 <span class="keyword">to</span> n_jobs () <span class="keyword">do</span>
  do_next_job ()
<span class="keyword">done</span></code></pre>

<p>Ocaml 中的 <code>for</code> 循环不过是下面这中形式的简写：</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">i</span> = 1 <span class="governing">in</span>
do_next_job ();
<span class="governing">let </span><span class="ocaml-variable">i</span> = 2 <span class="governing">in</span>
do_next_job ();
<span class="governing">let </span><span class="ocaml-variable">i</span> = 3 <span class="governing">in</span>
do_next_job ();
  ...
<span class="governing">let </span><span class="ocaml-variable">i</span> = n_jobs () <span class="governing">in</span>
do_next_job ();
()</code></pre>

<p>OCaml 不支持<code>for</code>循环中诸如 <code>break</code>, <code>continue</code> 或 <code>last</code> 这些语句的流控制（你可以
在循环体里抛出一个异常再在外面接著，但这个风格看起来太糟糕）。</p>
<p> OCaml 中 for 循环的表达式必须被返回 <code>unit</code>（否则你会接收到一个警告），并且for循环本身也会返回
 <code>unit</code>:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="keyword">for</span> i = 1 <span class="keyword">to</span> 10 <span class="keyword">do</span> <span class="ocaml-error-loc">i</span> <span class="keyword">done</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr">Warning 10: this expression should have type unit.
</span>- : unit = ()
</span></code></pre>

<p>函数式程序员更倾向于用递归，而不是for循环，由于for循环没有返回值，因此Ocaml中的for循环
并不这么有用。我们会在下面讨论递归。</p>
<p><strong>While 循环</strong> 是写成：</p>
<pre><code class="ocaml"><span class="keyword">while</span> boolean-condition <span class="keyword">do</span>
  expression
<span class="keyword">done</span></code></pre>

<p>和for循环同样，while循环也不支持循环流控制，当然你还是可以用异常，但这说明while循环
其实是相当受限制的。同样，函数式程序员更喜欢递归，因此while循环是二等公民。</p>
<p>如果你改变一下思维，其实你会发现你完全用不到while循环，除非你使用到引用。假设Ocaml
不支持引用：</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">quit_loop</span> = false <span class="governing">in</span>
<span class="keyword">while</span> not quit_loop <span class="keyword">do</span>
  print_string <span class="string">&quot;Have you had enough yet? (y/n) &quot;</span>;
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_line () <span class="governing">in</span>
  <span class="keyword">if</span> str.[0] = <span class="string">'y'</span> <span class="keyword">then</span>
    <span class="comment">(* how <span class="keyword">do</span> I set quit_loop <span class="keyword">to</span> true ?!? *)</span>
<span class="keyword">done</span></code></pre>

<p> <code>quit_loop</code> 不是一个真正的变量，let 绑定只是让 <code>quit_loop</code> 成为 <code>false</code> 的简写。
这就是说while循环的条件语句总是会真的，因此这是一个死循环！</p>
<p>幸运的是OCaml是<em>有</em>引用的，所以我们可以写出想要的代码。但是不要误会 <code>!</code> 是C/Java中的
非，在OCaml中是“解引用”的意思。你最好把 <code>!</code> 读作“解引”：</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">quit_loop</span> = <span class="keyword">ref</span> false <span class="governing">in</span>
<span class="keyword">while</span> not !quit_loop <span class="keyword">do</span>
  print_string <span class="string">&quot;Have you had enough yet? (y/n) &quot;</span>;
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_line () <span class="governing">in</span>
  <span class="keyword">if</span> str.[0] = <span class="string">'y'</span> <span class="keyword">then</span>
    quit_loop := true
<span class="keyword">done</span>;;</code></pre>

<h2 id="">迭代链表</h2><p>如果你要迭代整个链表，是时候改变一下思维，不要老挂记着老朋友for循环了。OCaml有更好更快的方式
来迭代整个链表，这些函数都在<code>List</code> 模块里。在这个模块里有很多很好的函数，不过下面我只会讨论最
有用的一组。</p>
<p>首先我们先定义一个链表：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">my_list</span> = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val my_list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</span></code></pre>

<p>如果你想迭代链表中的每个元素各一次，用<code>List.iter</code>, 如下：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">elem </span>=
    <span class="ocaml-module">Printf</span>.printf <span class="string">&quot;I'm looking at element %d now\n&quot;</span> elem <span class="governing">in</span>
    <span class="ocaml-module">List</span>.iter f my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">I'm looking at element 1 now
I'm looking at element 2 now
I'm looking at element 3 now
I'm looking at element 4 now
I'm looking at element 5 now
I'm looking at element 6 now
I'm looking at element 7 now
I'm looking at element 8 now
I'm looking at element 9 now
I'm looking at element 10 now
</span><span class="ocaml-stderr"></span>- : unit = ()
</span></code></pre>

<p>当你想用for循环的时候，<code>List.iter</code> 应该是你的首选。</p>
<p>如果你想<em>变换</em>链表中的每个元素，比方说给每个元素翻倍，则可以用 <code>List.map</code>。Perl程序员可能
会对下面的函数用法感到熟悉：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.map (( * ) 2) my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]
</span></code></pre>

<p>Perl里，我们用<code>grep</code>来过滤某个条件，比方说返回所有偶数。OCaml中这个函数叫 <code>List.filter</code>:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">is_even</span> <span class="ocaml-variable">i </span>=
    i mod 2 = 0 <span class="governing">in</span>
  <span class="ocaml-module">List</span>.filter is_even my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [2; 4; 6; 8; 10]
</span></code></pre>

<p>如果要找出链表中是否包含某个元素，则要用 <code>List.mem</code>：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.mem 12 my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : bool = false
</span></code></pre>

<p><code>List.for_all</code> 和 <code>List.exists</code> 的意思跟逻辑里的“任意”和“存在”是一样的。</p>
<p>如果要同时操作两个链表，我们有下面这些函数的“-2”变体，也就是
<code>iter2</code>, <code>map2</code>, <code>for_all2</code>,<code>exists2</code>。</p>
<p> <code>map</code> 和 <code>filter</code> 函数单独操作每个链表的元素。<code>Fold</code> 则是一个不同寻常的函数，它
表示在链表的元素之间插入一个操作符。比方说我想把链表中所有的数字相加，因此我想在元素之间
插入一个加号：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 55
</span></code></pre>

<p><code>Fold</code>支持这个操作，但是细节比较麻烦。首先，操作在空链表该返回什么？在这里如果是0则是最好的。
但是如果我们想要求链表的积，则我会想要返回1。所以我要提供某种默认值，然后第二个问题是，
怎么应对不符合结合律的复杂操作，诸如 (a <em>op</em> b) <em>op</em> c 不等于 a <em>op</em> (b <em>op</em> c)?
在这个情况下，从左至右还是反过来则会影响结果。因此我们有两个版本 <code>List.fold_left</code> (从左到右)和
<code>List.fold_right</code> (从右到左)。</p>
<p>让我们用 <code>List.fold_left</code> 来定义 <code>sum</code> 和 <code>product</code> 函数：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">sum</span> = <span class="ocaml-module">List</span>.fold_left ( + ) 0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val sum : int list -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">product</span> = <span class="ocaml-module">List</span>.fold_left ( * ) 1</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val product : int list -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">sum my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 55
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">product my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 3628800
</span></code></pre>

<p>这太简单了，现在我有一个方式来表示阶乘：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">fact</span> <span class="ocaml-variable">n </span>= product (range 1 n)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val fact : int -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">fact 10</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 3628800
</span></code></pre>

<p>（注意到这个阶乘函数并不是这么有用，因为对于较小的n它都引起整数溢出，一个真正的阶乘
应该使用 <code>Big_int</code> 模块）</p>
<h2 id="">迭代字符串</h2><p><code>String</code> 模块包含很多与字符串相关的函数，其中里面有一些迭代字符串的函数。</p>
<p><code>String.fill</code> 和 <code>String.blit</code> 和 C 的 <code>memset</code>， <code>strcpy</code> 等同。
 <code>String.copy</code> 如同 <code>strdup</code> 拷贝一个字符串。</p>
<p><code>String.iter</code> 则如 <code>List.iter</code>，不过是迭代字符串中的字符。</p>
<h2 id="">递归</h2><p>现在我们进入更难的话题：递归了。没有递归党，就没有函数式程序员。而且函数式中的递归和循环
在很多方面上是等价的。在函数式语言中，循环是二等公民，而递归则是支持地最好的。</p>
<p>写递归函数需要想法上的改变。在这一节我会给大家提供一些入门指导和例子。</p>
<p>在第一个例子里，我们讲把整个文件读到字符串里，一般来讲，有三个方法来实现：</p>
<h3 id="">方法一</h3><p>求文件的长度，然后用<code>really_input</code> 一次性地读进内存。这是最简单的方式，但是对于一些并非
一般文件的文件（比方说键盘），则不太好使了。</p>
<h3 id="">方法二</h3><p>这是过程式的方法，用一个while循环，并且通过抛出异常跳出。</p>
<h3 id="">方法三</h3><p>一个递归循环，也是通过异常跳出。</p>
<p>我们下面将要介绍几个新的概念。方法二、三将用到 <code>Buffer</code> 模块：一个可以扩展的缓冲，你可以认为
这是一个可以很有效率地拼接字符串的缓冲区。而函数将在读到文件尾的时候抛出 <code>End_of_file</code> 异常。
另外我们用 <code>Sys.argv.(1)</code> 来得到第一个命令行参数。</p>
<pre><code class="ocaml"><span class="comment">(* Read whole file: &#26041;&#27861;&#19968; *)</span>
<span class="governing">open</span> <span class="ocaml-module">Printf</span>
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_chan</span> <span class="ocaml-variable">chan </span>=
  <span class="governing">let </span><span class="ocaml-variable">len</span> = in_channel_length chan <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">result</span> = <span class="ocaml-module">String</span>.create len <span class="governing">in</span>
  really_input chan result 0 len;
  result
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_file</span> <span class="ocaml-variable">filename </span>=
  <span class="governing">let </span><span class="ocaml-variable">chan</span> = open_in filename <span class="governing">in</span>
  read_whole_chan chan
  
<span class="governing">let</span> () =
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = <span class="ocaml-module">Sys</span>.argv.(1) <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_whole_file filename <span class="governing">in</span>
  printf <span class="string">&quot;I read %d characters from %s\n&quot;</span> (<span class="ocaml-module">String</span>.length str) filename</code></pre>

<p>方法一不会工作得很好，因为 <code>read_whole_chan</code> 并不能很好地读取诸如键盘和套接口这种非一般文件，
方法二将用到while循环：</p>
<pre><code class="ocaml"><span class="comment">(* Read whole file: &#26041;&#27861;&#20108; *)</span>
<span class="governing">open</span> <span class="ocaml-module">Printf</span>
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_chan</span> <span class="ocaml-variable">chan </span>=
  <span class="governing">let </span><span class="ocaml-variable">buf</span> = <span class="ocaml-module">Buffer</span>.create 4096 <span class="governing">in</span>
  <span class="keyword">try</span>
    <span class="keyword">while</span> true <span class="keyword">do</span>
      <span class="governing">let </span><span class="ocaml-variable">line</span> = input_line chan <span class="governing">in</span>
      <span class="ocaml-module">Buffer</span>.add_string buf line;
      <span class="ocaml-module">Buffer</span>.add_char buf '\n'
    <span class="keyword">done</span>;
    <span class="keyword">assert</span> false <span class="comment">(* This is never executed
                    (always <span class="keyword">raise</span> Assert_failure). *)</span>
  <span class="keyword">with</span>
    End_of_file -&gt; <span class="ocaml-module">Buffer</span>.contents buf
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_file</span> <span class="ocaml-variable">filename </span>=
  <span class="governing">let </span><span class="ocaml-variable">chan</span> = open_in filename <span class="governing">in</span>
  read_whole_chan chan
  
<span class="governing">let</span> () =
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = <span class="ocaml-module">Sys</span>.argv.(1) <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_whole_file filename <span class="governing">in</span>
  printf <span class="string">&quot;I read %d characters from %s\n&quot;</span> (<span class="ocaml-module">String</span>.length str) filename</code></pre>

<p>方法二的关键在中间的while循环。还记得我上面提到抛异常是提早跳出循环的唯一方式？
这就是我们在这里的解决方案。虽然我还没有提到异常，但我估计你应该可以理解 <code>input_line</code> 
会遇到文件结尾的时候会抛出 <code>End_of_file</code> 异常。缓冲 <code>buf</code>
会累积文件的内容，然后当遇到文件结尾的时候则返回这个缓冲(<code>Buffer.contents buf</code>)。</p>
<p>一个有意思的地方是，为什么在while循环最后有一个多余的语句(<code>assert false</code>)呢？要知道
OCaml中的while和for循环是表达式，它们的返回值总是 <code>unit</code> 对象 (<code>()</code>)。
但是OCaml要求<code>try</code>的返回值要和每个接收的表达式的返回值匹配。在这个情况，因为 <code>End_of_file</code>
的结果是 <code>string</code>，因此<code>try</code> 也必须返回一个字符串，尽管这个while是死循环。<code>assert false</code>
表达式是一个多态表达式，因此可以自动匹配<code>with</code>分支的返回类型。</p>
<p>下面是我们的递归版本。注意到该版本比方法二更短，但是对于过程式程序员来讲可能并不那么容易理解：</p>
<pre><code class="ocaml"><span class="comment">(* Read whole file: Approach 3 *)</span>
<span class="governing">open</span> <span class="ocaml-module">Printf</span>
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_chan</span> <span class="ocaml-variable">chan </span>=
  <span class="governing">let </span><span class="ocaml-variable">buf</span> = <span class="ocaml-module">Buffer</span>.create 4096 <span class="governing">in</span>
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
    <span class="governing">let </span><span class="ocaml-variable">line</span> = input_line chan <span class="governing">in</span>
    <span class="ocaml-module">Buffer</span>.add_string buf line;
    <span class="ocaml-module">Buffer</span>.add_char buf '\n';
    loop () <span class="governing">in</span>
  <span class="keyword">try</span>
    loop ()
  <span class="keyword">with</span>
    End_of_file -&gt; <span class="ocaml-module">Buffer</span>.contents buf
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_file</span> <span class="ocaml-variable">filename </span>=
  <span class="governing">let </span><span class="ocaml-variable">chan</span> = open_in filename <span class="governing">in</span>
  read_whole_chan chan
  
<span class="governing">let</span> () =
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = <span class="ocaml-module">Sys</span>.argv.(1) <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_whole_file filename <span class="governing">in</span>
  printf <span class="string">&quot;I read %d characters from %s\n&quot;</span> (<span class="ocaml-module">String</span>.length str) filename</code></pre>

<p>这里同样有一个死循环，但是是用递归来实现的。<code>loop</code> 在末尾调用了它本身，这个死循环会在
 <code>input_line</code> 抛出 <code>End_of_file</code> 异常的时候跳出。</p>
<p>这看起来好像方法三在文件足够大的时候会导致堆栈溢出，但实际上并非如此。因为这是一个尾递归
调用，编译器会把这段代码编译成一个while循环，因此这里只会用到常数大小的堆栈。</p>
<p>在下一个例子我们会展示递归在构造或者试验某种类型的数据结构上有很卓越的表现，尤其是树。
让我们来定义一个文件系统的递归类型：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">filesystem</span> = File <span class="keyword">of</span> string | Directory <span class="keyword">of</span> filesystem list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type filesystem = File of string | Directory of filesystem list
</span></code></pre>

<p><code>opendir</code> 和 <code>readdir</code> 函数将被用来打开和读取目录。我将定义一个有用的函数
<code>readdir_no_ex</code> ，它会隐藏 <code>readdir</code> 抛出的烦人的 <code>End_of_file</code> 异常：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">open</span> <span class="ocaml-module">Unix</span>  <span class="comment">(*  You may need <span class="keyword">to</span> #load <span class="string">&quot;<span class="ocaml-module">Unix</span>.cma&quot;</span> *)</span>
    
  <span class="governing">let</span> <span class="ocaml-function">readdir_no_ex</span> <span class="ocaml-variable">dirh </span>=
    <span class="keyword">try</span>
      Some (readdir dirh)
    <span class="keyword">with</span>
      End_of_file -&gt; None</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val readdir_no_ex : Unix.dir_handle -&gt; string option = &lt;fun&gt;
</span></code></pre>

<p> <code>readdir_no_ex</code> 的类型如下，回忆以下先前我们讨论过的null指针：</p>
<pre><code class="ocaml">readdir_no_ex : dir_handle -&gt; string option</code></pre>

<p>下面我回定义一个递归函数来将 <code>filesystem</code> 类型转变成字符串用来打印：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">string_of_filesystem</span> <span class="ocaml-variable">fs </span>=
    <span class="keyword">match</span> fs <span class="keyword">with</span>
    | File filename -&gt; filename ^ <span class="string">&quot;\n&quot;</span>
    | Directory fs_list -&gt;
        <span class="ocaml-module">List</span>.fold_left (^) <span class="string">&quot;&quot;</span> (<span class="ocaml-module">List</span>.map string_of_filesystem fs_list)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val string_of_filesystem : filesystem -&gt; string = &lt;fun&gt;
</span></code></pre>

<p>这里我们用到了 <code>fold_left</code> 和 <code>map</code>。 <code>map</code> 这里将链表中的每个 <code>filesystem</code> 递归地转
变成 <code>string</code>。而 <code>fold_left (^) &quot;&quot;</code> 会把一个链表串接成一个长字符串。注意到这里用到了
模式匹配。（库定义了一个函数 <code>String.concat</code> 实现和 <code>fold_left (^) </code>等同的小鬼，
但是更加迅速）。</p>
<p>现在我们将定义一个函数来递归地读取目录结构，然后返回一个递归的 <code>filesystem</code> 数据结构哦。我将
分几步展示这个函数。但是我回在最后展示整个函数。首先这个函数的轮廓如下：</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
  <span class="governing">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="governing">in</span>
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
    <span class="comment">(* ..... *)</span> <span class="governing">in</span>
  Directory (loop ())</code></pre>

<p><code>opendir</code> 打开一个路径并返回一个 <code>dir_handle</code> ，然后我们会用 <code>readdir_no_ex</code> 来读取这个
句柄下的所有名字。这个函数的返回值会是 <code>Directory fs_list</code>，所以我们下面我们要完成的是
 <code>loop</code> 函数，它会返回一个 <code>filesystem</code> 链表。 <code>loop</code> 的类型应该是：</p>
<pre><code class="ocaml">loop : unit -&gt; filesystem list</code></pre>

<p>那我们该怎么定义<code>loop</code>？让我们一步一步地做：</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = readdir_no_ex dirh <span class="governing">in</span>
  <span class="comment">(* ..... *)</span></code></pre>

<p>首先我们要从目录句柄里读取下一个文件名。 <code>filename</code> 是一个 <code>string option</code>，也就是说它可以是
 <code>None</code> 或者 <code>Some &quot;foo&quot;</code>， <code>foo</code> 是目录下的下一个文件名。我们还要忽略 <code>&quot;.&quot;</code> 和 <code>&quot;..&quot;</code> 文件
（分别是当前目录和父目录）。通过模式匹配可以很轻松地实现这一点：</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = readdir_no_ex dirh <span class="governing">in</span>
  <span class="keyword">match</span> filename <span class="keyword">with</span>
  | None -&gt; []
  | Some <span class="string">&quot;.&quot;</span> -&gt; loop ()
  | Some <span class="string">&quot;..&quot;</span> -&gt; loop ()
  | Some filename -&gt;
     <span class="comment">(* ..... *)</span></code></pre>

<p><code>None</code>的时候很简单，如果<code>loop</code>到了目录尾，<code>loop</code>要返回一个文件名的链表，但是没有文件名阿，
所以应该返回一个空链表(<code>[]</code>)。</p>
<p>对于 <code>&quot;.&quot;</code> 和 <code>&quot;..&quot;</code> 我们只要简单地忽略它，再调用一遍 <code>loop</code> 即可。</p>
<p>那我们该怎样处理 <code>loop</code> 正常返回文件名的情况呢（ <code>Some filename</code> 的情况）？令<code>pathname</code>
是文件路径，首先我们得先判断这个文件是否目录，如果是的话，我们将
<code>this</code>的值设成 <code>read_directory</code> 递归调用的返回值，类型是<code>Directory something</code>。
注意到整个函数<code>read_directory</code> 的返回值是 <code>Directory (loop ())</code>。 如果文件是一个
普通文件，则我们让<code>this</code>的值是 <code>File pathname</code>。然后我们很巧妙地返回 <code>this :: loop ()</code>。
这里的 <code>loop ()</code> 的递归调用来计算目录的剩余成员，并把这些成员接在 <code>this</code> 的后面。</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
    <span class="governing">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="governing">in</span>
    <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
      <span class="governing">let </span><span class="ocaml-variable">filename</span> = readdir_no_ex dirh <span class="governing">in</span>
      <span class="keyword">match</span> filename <span class="keyword">with</span>
      | None -&gt; []
      | Some <span class="string">&quot;.&quot;</span> -&gt; loop ()
      | Some <span class="string">&quot;..&quot;</span> -&gt; loop ()
      | Some filename -&gt;
          <span class="governing">let </span><span class="ocaml-variable">pathname</span> = path ^ <span class="string">&quot;/&quot;</span> ^ filename <span class="governing">in</span>
          <span class="governing">let </span><span class="ocaml-variable">stat</span> = lstat pathname <span class="governing">in</span>
          <span class="governing">let </span><span class="ocaml-variable">this</span> = <span class="keyword">if</span> stat.st_kind = S_DIR <span class="keyword">then</span>
                       read_directory pathname
                     <span class="keyword">else</span>
                       File pathname <span class="governing">in</span>
          this :: loop () <span class="governing">in</span>
    Directory (loop ())</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val read_directory : string -&gt; filesystem = &lt;fun&gt;
</span></code></pre>

<p>这个递归有点复杂，虽然这个例子是生造的，但这个复杂的递归模式在现实生活中是很典型的。
这个例子主要指出了两个点：</p>
<ul><li><p>用递归来创建一个链表：</p>
<pre class="ocaml"><code class="ocaml"><span class="governing">let</span> <span class="governing">rec</span> <span class="lower">loop</span> <span class="keywordsign">(</span><span class="keywordsign">)</span> <span class="keywordsign">=</span>
  <span class="lower">a</span> <span class="keyword">match</span> <span class="keywordsign">or</span> <span class="keyword">if</span> <span class="lower">statement</span>
  <span class="keywordsign">|</span> <span class="lower">base</span> <span class="lower">case</span> <span class="keywordsign">-&#62;</span> <span class="keywordsign operator">[]</span>
  <span class="keywordsign">|</span> <span class="lower">recursive</span> <span class="lower">case</span> <span class="keywordsign">-&#62;</span> <span class="lower">element</span> <span class="keywordsign">::</span> <span class="lower">loop</span> <span class="keywordsign">(</span><span class="keywordsign">)</span></code></pre><p>把这和之前的<code>range</code>函数比较，这个递归的模式是一样的：</p>
<pre class="ocamltop"><code class="ocamltop">let rec range a b =
  if a &gt; b then []            (* Base case *)
  else a :: range (a+1) b     (* Recursive case *)</code></pre></li><li><p>用递归来创建一个树：</p>
<pre class="ocaml"><code class="ocaml"><span class="governing">let</span> <span class="governing">rec</span> <span class="lower">read_directory</span> <span class="lower">path</span> <span class="keywordsign">=</span>
  <span class="comment">(* blah blah *)</span>
  <span class="keyword">if</span> <span class="lower">file</span><span class="keywordsign">-</span><span class="lower">is</span><span class="keywordsign">-</span><span class="lower">a</span><span class="keywordsign">-</span><span class="lower">directory</span> <span class="keyword">then</span>
    <span class="lower">read_directory</span> <span class="lower">path</span><span class="keywordsign">-</span><span class="keyword">to</span><span class="keywordsign">-</span><span class="lower">file</span>
  <span class="keyword">else</span>
    <span class="constructor module">Leaf</span> <span class="lower">file</span></code></pre><p>接下来的，不就是几行代码，调用 <code>read_directory</code> 并打印其结果罢了：</p>
<pre class="ocaml"><code class="ocaml"><span class="governing">let</span> <span class="lower">path</span> <span class="keywordsign">=</span> <span class="constructor module">Sys</span><span class="keywordsign">.</span><span class="lower">argv</span><span class="keywordsign">.</span><span class="keywordsign">(</span><span class="number">1</span><span class="keywordsign">)</span> <span class="governing">in</span>
<span class="governing">let</span> <span class="lower">fs</span> <span class="keywordsign">=</span> <span class="lower">read_directory</span> <span class="lower">path</span> <span class="governing">in</span>
<span class="lower">print_endline</span> <span class="keywordsign">(</span><span class="lower">string_of_filesystem</span> <span class="lower">fs</span><span class="keywordsign">)</span></code></pre></li></ul>

<h3 id="">附录</h3><p>当我把这个例子发到 the caml-list mailing list后，我收到很多回帖。 (
<a href="http://caml.inria.fr/pub/ml-archives/caml-list/2003/06/2732fbf1bed1ae50fefb6ea410ea9955.en.html">前方英语注意</a>.)</p>
<p>首先 <code>read_directory</code> 有一个很基本的错误就是当这个函数调用在很大的目录的时候，
这个函数会出错。我也没有显式地调用 <code>closedir</code> 关闭这个目录句柄。OCaml的垃圾收集
这里不发挥作用，因为文件句柄是不会被收集和自动关闭的。</p>
<p>这很容易打上补丁：只要在 <code>read_directory</code> 的最后调用 <code>closedir</code> 一次即可：</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
  <span class="governing">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="governing">in</span>
    <span class="comment">(* ... *)</span>
  <span class="governing">let </span><span class="ocaml-variable">result</span> = Directory (loop ()) <span class="governing">in</span>
  closedir dirh;
  result</code></pre>

<p>下一个问题是 <code>readdir</code> 会在一个“非异常”情形下抛出一个 <code>End_of_file</code> 异常。我不认为
在这个情况下抛异常是一种好的风格。在一般的程序，我完全不想写 <code>try ... with</code> 语句，因为
异常往往表示有无法处理的问题发生，比如说用完硬盘或者内存。在程序内部抛出并接收，这不是一个
异常的情况（但是调用<code>readdir</code>的程序则要准备处理<code>End_of_file</code>异常)。</p>
<p>但是 Eric Cooper 找到一种方式来写这个函数并处理这个异常，而这还是一个函数式中很常用的技术。
这就是传入一个<strong>累积器</strong>来累积函数的返回结果，但是是通过参数传入。实际上累积器表示目前为止
函数的返回值，所以当遇到异常(<code>End_of_file</code>)，我们则放弃并返回目前的结果。下面是他的代码。累积器
标红：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">read_filesystem</span> <span class="ocaml-variable">path </span>=
    <span class="keyword">if</span> (lstat path).st_kind = S_DIR <span class="keyword">then</span>
      Directory (read_directory path)
    <span class="keyword">else</span>
      File path
    
  <span class="governing"><span class="governing">and</span></span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
    <span class="governing">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="governing">in</span>
    <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">entries </span>=
      <span class="keyword">try</span>
        <span class="keyword">match</span> readdir dirh <span class="keyword">with</span>
        | <span class="string">&quot;.&quot;</span> | <span class="string">&quot;..&quot;</span> -&gt; loop entries
        | filename -&gt;
           loop (read_filesystem (path ^ <span class="string">&quot;/&quot;</span> ^ filename) :: entries)
      <span class="keyword">with</span> End_of_file -&gt; entries <span class="governing">in</span>
    <span class="governing">let </span><span class="ocaml-variable">list</span> = loop [] <span class="governing">in</span>
    closedir dirh;
    list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val read_filesystem : string -&gt; filesystem = &lt;fun&gt;
val read_directory : string -&gt; filesystem list = &lt;fun&gt;
</span></code></pre>

<p>注意 <code>End_of_file -&gt; entries</code> 表示当我们遇到异常的时候，直接返回结果。</p>
<p>下面，有人指出最简单的实现方式完全不用递归，而用命令式的循环（最好是while循环），并且
用一个引用的链表来存储所有累积的结果。因为 <code>readdir</code> 抛出一个异常，我们有一个简单的方式来
跳出循环，并且在<code>with</code>-语句我们可以直接返回 <code>!list</code> (解引累积结果)。</p>
<p>这个组织行得通，并且证明了往往这个时候采用命令式的方法是最好的，尤其是这里
<code>opendir ... readdir ... closedir</code> 都是命令式的 API。
所以用命令式的解决方案更简单是完全不奇怪的。OCaml不规定原则性的规条，它不会在意
在合理的地方使用命令式的方法。</p>
<p>下面是 Fabrice Le Fessant 提供的解决方法：</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">list</span> = <span class="keyword">ref</span> [] <span class="governing">in</span>
<span class="governing">let </span><span class="ocaml-variable">dir</span> = opendir <span class="string">&quot;.......&quot;</span> <span class="governing">in</span>
<span class="keyword">try</span>
  <span class="keyword">while</span> true <span class="keyword">do</span>
    <span class="keyword">match</span> readdir dir <span class="keyword">with</span>
    | <span class="string">&quot;.&quot;</span> | <span class="string">&quot;..&quot;</span> -&gt; ()
    | filename -&gt; list := filename :: !list
  <span class="keyword">done</span>;
  <span class="keyword">assert</span> false
<span class="keyword">with</span> End_of_file -&gt; !list</code></pre>

<h3 id="">递归例子：链表中最大的元素</h3><p>链表的基本递归模式是：</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  a <span class="keyword">match</span> or <span class="keyword">if</span> statement
  | base case -&gt; []
  | recursive case -&gt; element :: loop ()</code></pre>

<p>这里的关键是实际上是match / 基本情况 / 递归情况模式。在这个例子里，我们将有两个基本情况
和一个递归情况。不过在我们展示代码之前，首先让我们先考虑以下问题本身。当我们熟虑之后，
解决方案就会自己出现。</p>
<p>首先，我们先清楚链表最大值就是最大的元素（译注：原文废话如此，估计外国人数学太差），比方说
 <code>[1; 2; 3; 4; 1]</code>的最大值是 <code>4</code>。</p>
<p>那有特殊情况吗？有的，那就是空链表，这时没有最大值，因此我们应该抛出一个异常。</p>
<p>那对于一个只有一个元素的链表呢，如 <code>[4]</code> ？很简单，就是这个元素本身。所以 <code>list_max [4]</code>
应该返回4， 或者说 <code>list_max [x]</code> 应该返回 <code>x</code>。</p>
<p>那什么是 <code>x :: remainder</code> 的最大值呢？</p>
<p>先考虑一下，比方说你知道了<code>remainder</code>的最大值，令其为 <code>y</code>。那<code>x :: remainder</code>的最大值是
什么？这取决于 <code>x &gt; y</code> 还是 <code>x &lt;= y</code>。如果 <code>x</code> 大于 <code>y</code>，则应该是 <code>x</code>，否则应该是 <code>y</code>。
（译注：鬼佬的数学真的太差了，这都能解释得这么冗长）</p>
<p>那这是否真的可行呢？再看看 <code>[1; 2; 3; 4; 1]</code> = <code>1 :: [2; 3; 4; 1]</code>。现在<code>[2; 3; 4; 1]</code>
的最大值是 <code>4</code>。现在我们再看看 <code>x = 1</code> 和 <code>y = 4</code>。 <code>x = 1</code> 没有影响，因为 <code>y = 4</code> 更大，
所以整个链表的最大值是 <code>y = 4</code>。</p>
<p>让我们直接来看看代码：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">list_max</span> <span class="ocaml-variable">xs </span>=
      <span class="keyword">match</span> xs <span class="keyword">with</span>
      | [] -&gt;   <span class="comment">(* empty list: fail *)</span>
         <span class="keyword">failwith</span> <span class="string">&quot;list_max called on empty list&quot;</span>
      | [x] -&gt; <span class="comment">(* single element list: return the element *)</span>
         x
      | x :: remainder -&gt; <span class="comment">(* multiple element list: recursive case *)</span>
         max x (list_max remainder)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val list_max : 'a list -&gt; 'a = &lt;fun&gt;
</span></code></pre>

<p>我已经在相应的位置加上了注释。那它是否可行呢？</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">list_max [1; 2; 3; 4; 1]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 4
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">list_max []</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>Exception: Failure &quot;list_max called on empty list&quot;.
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">list_max [5; 4; 3; 2; 1]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 5
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">list_max [5; 4; 3; 2; 1; 100]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 100
</span></code></pre>

<p>注意这个解决方案是 （1） 不同于命令式的for循环 （2）更接近问题的描述本身。函数式程序员
会告诉你这是因为函数式的风格比命令式风格更高级，因此更加好更加简单。不管你是否相信这个说法，
函数式的版本更加容易理解里面的逻辑，因此也更容易证明这段代码是正确的（正确是指数学意义上
程序是可以证明是没有bug的，可以用作空间站，核子反应堆或者其他高质量软件）。</p>
<h3 id="">尾递归</h3><p>让我们再来看看 <code>range</code> 函数：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> []
    <span class="keyword">else</span> a :: range (a+1) b</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>下面我将重写这个函数让结构更加清楚点（但是没改变这个函数）：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> []
    <span class="keyword">else</span>
      <span class="governing">let </span><span class="ocaml-variable">result</span> = range (a+1) b <span class="governing">in</span>
      a :: result</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>让我们来调用这个函数：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.length (range 1 10)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 10
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.length (range 1 1000000)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>Stack overflow during evaluation (looping recursion?).
</span></code></pre>

<p>这看起来好像是递归的问题，因此整个函数式都是问题。如果我们总是写递归函数，那么我们将终有一天
遇到堆栈溢出。</p>
<p>实际上并不是这样的。编译器会对某种递归进行优化，并把它变成while循环。因此这种形式的递归
只用到常数量的堆栈，且与while循环一样迅速。这些函数叫做<strong>尾递归函数</strong>。</p>
<p>在尾递归函数里，所有的递归调用都在函数的返回点。还记得 <code>loop ()</code> 函数吗？它们都有下面的形式：</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  <span class="comment">(* <span class="keyword">do</span> something *)</span>
  loop ()</code></pre>

<p>因为<code>loop()</code>的递归调用在最后，因此<code>loop</code>是尾递归的，编译器会将其编译成一个while循环。</p>
<p>不幸的是，<code>range</code>并不是尾递归的，而更长的版本告诉了我们为什么。 <code>range</code> 的递归调用
并不发生在最后，实际上，最后进行的操作是 <code>::</code> (cons) 操作。实际上，编译器不会将其
转变成一个while循环，并且这个实现对堆栈也不友好。</p>
<p>记得我们在上面的附录中提到 Eric Cooper 的累积器技巧，而这个技术被广泛使用在函数式中。
我们会知道为什么会这样。这是因为你可以把<code>range</code>实现成尾递归的形式，这能让实现更下高效
能接收更大的输入。</p>
<p>让我们用累积器来记录<code>range</code>到目前为止的结果：</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
  <span class="comment">(* ... *)</span>
  
<span class="governing">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
  range2 a b []</code></pre>

<p>(我可能更加倾向于用嵌套函数)</p>
<p>这里的 <code>accum</code> 参数将用来累积结果。我们传入一个空链表。最简单的情况是 <code>a &gt; b</code>:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
  <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> accum
  <span class="keyword">else</span>
    <span class="comment">(* ... *)</span></code></pre>

<p>当 <code>a &gt; b</code> (也就是递归该结束了),则该返回结果了 (<code>accum</code>)。</p>
<p>现在的问题是写 <code>else</code>-语句 来保证 <code>range2</code> 在最后才被调用，来使它是一个尾递归函数：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> accum
    <span class="keyword">else</span> range2 (a+1) b (a :: accum)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>还有一个小问题：我们把这个链表创建反了。但是这很容易解决：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>= <span class="ocaml-module">List</span>.rev (range2 a b [])</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>现在这段代码可以工作了，尽管它运行得比较慢，因为它真的要创建一个长100w的链表：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.length (range 1 1000000)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 1000000
</span></code></pre>

<p>下面的实现基本有上面的两倍快，因为它不用反转整个链表：、</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
    <span class="keyword">if</span> b &lt; a <span class="keyword">then</span> accum
    <span class="keyword">else</span> range2 a (b-1) (b :: accum)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    range2 a b []</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>这是一个尾递归的简短介绍。但实际上，判断一个函数是否尾递归可以挺难的。那我们学到了什么？
其中一个就是递归函数可以非常危险。你的函数可能在小数据输入时工作正常，但是在大数据量的
时候就会引爆堆栈。这是一个不用递归而应更多用迭代的理由。</p>
<h2 id="records">可变 records, 引用和数组</h2><p>前面我们提到records，这个C中的 <code>struct</code>很像：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">pair_of_ints</span> = { a : int; b : int }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type pair_of_ints = { a : int; b : int; }
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">{a=3; b=5}</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : pair_of_ints = {a = 3; b = 5}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-error-loc">{a=3}</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: Some record fields are undefined: b
</span></code></pre>

<p>一点没有提到的是，OCaml的 records 可以有可变的域。通常一个表达式如 <code>{a = 3; b = 5}</code>
是不可变的。但是如果一个 record 有 <strong>可变域</strong>，因此可以改变这些域的值。
这是一个OCaml命令式的特性，因为函数式往往不允许可变对象。</p>
<p>这里是一个定义了可变域的对象。这个域是用来数这个对象使用的次数。者可以用作缓冲来
决定哪个对象留在内存：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">name</span> = { name : string; <span class="keyword">mutable</span> access_count : int }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type name = { name : string; mutable access_count : int; }
</span></code></pre>

<p>下面是一个定义在<code>name</code>类的函数，它打印<code>name</code>域并且增加 <code>access_count</code> 域：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">print_name</span> <span class="ocaml-variable">name </span>=
    print_endline (<span class="string">&quot;The name is &quot;</span> ^ name.name);
    name.access_count &lt;- name.access_count + 1</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val print_name : name -&gt; unit = &lt;fun&gt;
</span></code></pre>

<p>注意到一个奇怪的而非函数式的地方：它修改了 <code>access_count</code> 域。如果你认真读了第五章，
你会发现这个函数不是纯的。OCaml是一个函数式语言，但并不强制所有的函数都是纯的。</p>
<p>不管如何，让我们来调用一番：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">n</span> = { name = <span class="string">&quot;Richard Jones&quot;</span>; access_count = 0 }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val n : name = {name = &quot;Richard Jones&quot;; access_count = 0}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : name = {name = &quot;Richard Jones&quot;; access_count = 0}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">print_name n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">The name is Richard Jones
</span><span class="ocaml-stderr"></span>- : unit = ()
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : name = {name = &quot;Richard Jones&quot;; access_count = 1}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">print_name n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">The name is Richard Jones
</span><span class="ocaml-stderr"></span>- : unit = ()
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : name = {name = &quot;Richard Jones&quot;; access_count = 2}
</span></code></pre>

<p>只有显式地标志 <code>mutable</code> 的域可以被<code>&lt;-</code> 操作符赋值。如果你对不可变的域赋值，OCaml
则会报错：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-error-loc">n.name &lt;- </span><span class="string"><span class="ocaml-error-loc">&quot;John Smith&quot;</span></span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: The record field name is not mutable
</span></code></pre>

<p>引用是用records和一个可变域 <code>contents</code> 来实现的。下面是 <code>Pervasives</code> 中的定义：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">'a <span class="keyword">ref</span></span> = { <span class="keyword">mutable</span> contents : 'a }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type 'a ref = { mutable contents : 'a; }
</span></code></pre>

<p>并且看清楚Ocaml toplevel如何打印这个引用：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">r</span> = <span class="keyword">ref</span> 100</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val r : int Stdlib.ref = {Stdlib.contents = 100}
</span></code></pre>

<p>数组是OCaml中另一种可变的数据结构。在OCaml中，链表对某种操作是比较慢的，比方说跳到
第n个元素或者随机索引，都会很慢。OCaml的<code>Array</code>类型是一个真正的数组，所以随机索引很快，但是
插入和删除很慢。 <code>Array</code> 相当可变，你可以随便更改元素的值。</p>
<p>数组很容易操作：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">a</span> = <span class="ocaml-module"><span class="ocaml-error-loc">Array</span></span><span class="ocaml-error-loc">.create</span> 10 0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr">Alert deprecated: Stdlib.Array.create
Use Array.make instead.
</span>val a : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="keyword">for</span> i = 0 <span class="keyword">to</span> <span class="ocaml-module">Array</span>.length a - 1 <span class="keyword">do</span>
    a.(i) &lt;- i
  <span class="keyword">done</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : unit = ()
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">a</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int array = [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9|]
</span></code></pre>

<p>定义数组的语法是： <code>[| element; element; ... |]</code></p>
<p>OCaml编译是设计成适用于大量数值运算的(大概就是fortran干的那些), 所以它包含很多
数字数组、向量和矩阵相关的优化。下面是一个密集矩阵乘法的跑分（译注：也就是说这个乘法是老老实实
用二位数组表示的）。注意这里用到了for循环，并且变成风格也相当命令式：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">size</span> = 30
  
  <span class="governing">let</span> <span class="ocaml-function">mkmatrix</span> <span class="ocaml-variable">rows cols </span>=
    <span class="governing">let </span><span class="ocaml-variable">count</span> = <span class="keyword">ref</span> 1
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">last_col</span> = cols - 1
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m</span> = <span class="ocaml-module">Array</span>.make_matrix rows cols 0 <span class="governing">in</span>
    <span class="keyword">for</span> i = 0 <span class="keyword">to</span> rows - 1 <span class="keyword">do</span>
      <span class="governing">let </span><span class="ocaml-variable">mi</span> = m.(i) <span class="governing">in</span>
      <span class="keyword">for</span> j = 0 <span class="keyword">to</span> last_col <span class="keyword">do</span>
        mi.(j) &lt;- !count;
        incr count
      <span class="keyword">done</span>;
    <span class="keyword">done</span>;
    m
  
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">inner_loop</span> <span class="ocaml-variable">k v m1i m2 j </span>=
    <span class="keyword">if</span> k &lt; 0 <span class="keyword">then</span> v
    <span class="keyword">else</span> inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j
  
  <span class="governing">let</span> <span class="ocaml-function">mmult</span> <span class="ocaml-variable">rows cols m1 m2 m3 </span>=
    <span class="governing">let </span><span class="ocaml-variable">last_col</span> = cols - 1
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">last_row</span> = rows - 1 <span class="governing">in</span>
    <span class="keyword">for</span> i = 0 <span class="keyword">to</span> last_row <span class="keyword">do</span>
      <span class="governing">let </span><span class="ocaml-variable">m1i</span> = m1.(i) <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m3i</span> = m3.(i) <span class="governing">in</span>
      <span class="keyword">for</span> j = 0 <span class="keyword">to</span> last_col <span class="keyword">do</span>
        m3i.(j) &lt;- inner_loop last_row 0 m1i m2 j
      <span class="keyword">done</span>;
    <span class="keyword">done</span>
  
  <span class="governing">let</span> () =
    <span class="governing">let </span><span class="ocaml-variable">n</span> =
      <span class="keyword">try</span> int_of_string <span class="ocaml-module">Sys</span>.argv.(1)
      <span class="keyword">with</span> Invalid_argument _ -&gt; 1
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m1</span> = mkmatrix size size
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m2</span> = mkmatrix size size
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m3</span> = <span class="ocaml-module">Array</span>.make_matrix size size 0 <span class="governing">in</span>
    <span class="keyword">for</span> i = 1 <span class="keyword">to</span> n - 1 <span class="keyword">do</span>
      mmult size size m1 m2 m3
    <span class="keyword">done</span>;
    mmult size size m1 m2 m3;
    <span class="ocaml-module">Printf</span>.printf <span class="string">&quot;%d %d %d %d\n&quot;</span> m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">270165 1061760 1453695 1856025
</span><span class="ocaml-stderr"></span>val size : int = 30
val mkmatrix : int -&gt; int -&gt; int array array = &lt;fun&gt;
val inner_loop : int -&gt; int -&gt; int array -&gt; int array array -&gt; int -&gt; int =
  &lt;fun&gt;
val mmult :
  int -&gt; int -&gt; int array array -&gt; int array array -&gt; int array array -&gt; unit =
  &lt;fun&gt;
</span></code></pre>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	
<div class="column">
  <div class="entry">
    <h1><a href="../../learn/">Learn</a></h1>
    <ul>
      <li><a href="../../learn/taste.html">Code Examples</a></li>
      <li><a href="../../learn/tutorials/index.zh.html">Tutorials</a></li>
      <li><a href="../../learn/books.html">Books</a></li>
      <li><a href="../../learn/success.html">Success Stories</a></li>
      <li><a href="."></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../docs/">Documentation</a></h1>
    <ul>
      <li><a href="../../docs/install.html">Install</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manual</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Packages</a></li>
      <li><a href="../../releases/index.html">Compiler Releases</a></li>
      <li><a href="../../docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../community/">Community</a></h1>
    <ul>
      <li><a href="../../community/mailing_lists.html">Mailing Lists</a></li>
      <li><a href="../../meetings/">Meetings</a></li>
      <li><a href="../../community/planet/">News</a></li>
      <li><a href="../../community/support.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Bug Tracker</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Website</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/if_statements_loops_and_recursion.zh.md" target="_blank">Edit this page</a></li>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Website Issues</a></li>
      <li><a href="../../about.html">About This Site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Find Us on GitHub</a></li>
      <li><a href="../../contributors.html">Credits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js" type="text/javascript"></script>

     

  </body>
</html>
