<!DOCTYPE HTML>


<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
  <head>
    <meta charset="utf-8"/>
    
    <link href="labels.html" rel="alternate" hreflang="en"/>
<link href="labels.ja.html" rel="alternate" hreflang="ja"/>
<link href="labels.zh.html" rel="alternate" hreflang="zh"/>

    
    <title>标签 &#8211; OCaml</title>
    <link href="../../img/favicon32x32.ico?" rel="shortcut icon" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <link href="//fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css"/>
    
    <link href="../../css/bootstrap.css" rel="stylesheet" media="screen"/>
    <link href="../../css/bootstrap_mod.css" rel="stylesheet" media="screen"/>
    <link href="../../css/ocamlorg.css" rel="stylesheet" media="screen"/>
    
    
    <script src="../../js/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="../../" class="brand"><img src="../../img/colour-logo-white.svg" class="svg" alt="OCaml"/><img src="../../img/colour-logo-white.png" class="png" alt="OCaml"/></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="../../learn/">Learn</a></li>
              <li><a href="../../docs/">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Packages</a></li>
              <li><a href="../../community/">Community</a></li>
              <li><a href="../../community/planet/">News</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/labels.zh.md" title="Edit this page" class="edit-this-page pull-right"><span>Edit this page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input type="hidden" name="as_sitesearch" value="ocaml.org"/>
              <input placeholder="Search" class="search-query" name="q" type="text"/>
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="../../">Home</a><span class="divider"></span></li>
<li><a href="../../learn/">Learn</a><span class="divider"></span></li>
<li><a href="../../learn/tutorials/index.zh.html">OCaml教程</a><span class="divider"></span></li>
<li class="active">标签</li>


    </ol>
    <ul class="translations">
      <li><a href="labels.html">en</a></li>
<li><a href="labels.ja.html">日本語</a></li>
<li class="active">中文</li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contents</a></li>
          <ul><li><a href="#">异常和哈希表</a>
</li><li><a href="#">互递归函数</a>
</li><li><a href="#">函数及其参数的别名</a>
</li><li><a href="#">标签化和可选参数</a>
<ul><li><a href="#">标签化参数</a>
</li><li><a href="#">可选参数</a>
</li><li><a href="#quot-Warning-This-optional-argument-cannot-be-erased-quot">&quot;Warning: This optional argument cannot be erased&quot;</a>
</li><li><a href="#">更多<code>~</code>简写</a>
</li><li><a href="#foo">函数调用中的 <code>?foo</code></a>
</li><li><a href="#">什么时候该用和不该用 <code>~</code> 和 <code>?</code></a>
</li><li><a href="#">附录</a>
</li></ul>
</li><li><a href="#">多态变体</a>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        

<h1 id="">标签</h1>

<h2 id="">异常和哈希表</h2><p><em>(英文版未完成)</em></p>
<h2 id="">互递归函数</h2><p>如果我要让两个函数互相调用对方，虽然这不是很常见的事情（译注：比方说大部分函数式语言的REPL就是
两个函数：<code>apply</code>和<code>eval</code>的互相调用），但这可以很有用。下面是一个生造的例子（感谢Ryan Tarpine）：
0是偶数，而对于其他大于0的数字，当它前一个数是奇的，那么他是偶的。那么：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">e<span class="ocaml-error-loc">ven</span></span><span class="ocaml-error-loc"></span> <span class="ocaml-variable">n </span>=
    <span class="keyword">match</span> n <span class="keyword">with</span>
    | 0 -&gt; true
    | x -&gt; odd (x-1)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: Unbound value odd
</span></code></pre>

<p>上面的代码不会编译，因为<code>odd</code>函数还没有定义。不过这很简单，因为0不是奇的，而大于0的数是奇的，仅当它前一个数是偶的。
因此我们可以定义这个函数：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">e<span class="ocaml-error-loc">ven</span></span><span class="ocaml-error-loc"></span> <span class="ocaml-variable">n </span>=
    <span class="keyword">match</span> n <span class="keyword">with</span>
    | 0 -&gt; true
    | x -&gt; odd (x-1)
    
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">odd</span> <span class="ocaml-variable">n </span>=
    <span class="keyword">match</span> n <span class="keyword">with</span>
    | 0 -&gt; false
    | x -&gt; even (x-1)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: Unbound value odd
</span></code></pre>

<p>但是还有个问题，这就是这段代码还是不会编译。因为要编译<code>even</code>，我们需要<code>odd</code>，但是<code>odd</code>
同样需要<code>even</code>，把这两个函数定义放一起也不能解决这个问题。</p>
<p>OCaml也没有C中的前置声明，不过有一个特殊的语法来定义这种多递归函数，如下：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">even</span> <span class="ocaml-variable">n </span>=
    <span class="keyword">match</span> n <span class="keyword">with</span>
    | 0 -&gt; true
    | x -&gt; odd (x-1)
  <span class="governing"><span class="governing">and</span></span> <span class="ocaml-function">odd</span> <span class="ocaml-variable">n </span>=
    <span class="keyword">match</span> n <span class="keyword">with</span>
    | 0 -&gt; false
    | x -&gt; even (x-1)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val even : int -&gt; bool = &lt;fun&gt;
val odd : int -&gt; bool = &lt;fun&gt;
</span></code></pre>

<p>这很难知道有哪些要用到多递归的例子，因为我们从来没有这么需要，我也不能给出很好的例子（译注：
这装的...）。总之就这样，你可以用这个简单的语法来定义多递归的类定义和模块。</p>
<h2 id="">函数及其参数的别名</h2><p>记得在第五章我们讲到过部分函数应用。这是一种整洁的方法来偷懒：为函数和参数起别名。</p>
<p>虽然我们还没有讲到面向对象，下面是一个OCamlNet的别名函数调用的例子，你只需要知道
<code>cgi # output # output_string &quot;string&quot;</code> 是一个函数调用，跟Java中的
<code>cgi.output().output_string (&quot;string&quot;)</code> 类似。</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">begin_page</span> <span class="ocaml-variable">cgi title </span>=
  <span class="governing">let </span><span class="ocaml-variable">out</span> = cgi # output # output_string <span class="governing">in</span>
  out <span class="string">&quot;&lt;html&gt;\n&quot;</span>;
  out <span class="string">&quot;&lt;head&gt;\n&quot;</span>;
  out (<span class="string">&quot;&lt;title&gt;&quot;</span> ^ text title ^ <span class="string">&quot;&lt;/title&gt;\n&quot;</span>);
  out (<span class="string">&quot;&lt;style <span class="governing">type</span>=\&quot;text/css\&quot;&gt;\n&quot;</span>);
  out <span class="string">&quot;body { background: white; color: black; }\n&quot;</span>;
  out <span class="string">&quot;&lt;/style&gt;\n&quot;</span>;
  out <span class="string">&quot;&lt;/head&gt;\n&quot;</span>;
  out <span class="string">&quot;&lt;body&gt;\n&quot;</span>;
  out (<span class="string">&quot;&lt;h1&gt;&quot;</span> ^ text title ^ <span class="string">&quot;&lt;/h1&gt;\n&quot;</span>)</code></pre>

<p><code>let out = ... </code> 是一个对那个方法的部分函数应用（这是部分，因为字符串参数还没有传入）。
<code>out</code>因而是一个接收一个字符串的函数。</p>
<pre><code class="ocaml">out <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</code></pre>

<p>等价于：</p>
<pre><code class="ocaml">cgi # output # output_string <span class="string">&quot;&lt;html&gt;\n&quot;</span>;</code></pre>

<p>我们这下偷了不少懒。</p>
<p>我们也可以加上参数。 <code>print_string</code>也可以定义成部分函数应用：</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">print_string</span> = output_string stdout</code></pre>

<p><code>output_string</code> 接收两个参数（一个channel一个字符串），但是由于我们只给出一个，因此他是一个
部分函数应用。因此 <code>print_string</code> 是一个接收一个字符串的函数。</p>
<h2 id="">标签化和可选参数</h2><h3 id="">标签化参数</h3>

<p>Python有一个很好的语法就是允许标签化参数：</p>
<pre class="python"><code class="python">def ask_ok(prompt, retries=4, complaint=&#39;Yes or no, please!&#39;):
  # function definition omitted</code></pre><p>下面是调用这个函数的一些方式：</p>
<pre class="python"><code class="python">ask_ok (&#39;Do you really want to quit?&#39;)
ask_ok (&#39;Overwrite the file?&#39;, 2)
ask_ok (prompt=&#39;Are you sure?&#39;)
ask_ok (complaint=&#39;Please answer yes or no!&#39;, prompt=&#39;Are you sure?&#39;)</code></pre><p>注意到Python中我们允许通过参数的名字传入值，也可以通过一般函数调用的形式，也允许我们
对可选参数带有默认值：</p>
<p>你也可以在Perl中做类似的事（译注：Perl是没有参数列表这种东西的，这个特性可以说是
语言本身的trick，相比Python甚不优雅）：</p>
<pre class="perl"><code class="perl">sub ask_ok
{
  my %params = @_;
  
  my $prompt = $params{prompt};
  my $retries = exists $params{retries} ? $params{retries} : 4;
  
  # ... etc.
}
  
ask_ok (prompt =&gt; &quot;Are you sure?&quot;, retries =&gt; 2);</code></pre><p>OCaml也可以有标签化和可选参数。</p>
<p>基本语法是：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">~first:a ~last:b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> []
    <span class="keyword">else</span> a :: range ~first:(a+1) ~last:b</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>（注意到<code>to</code>和<code>end</code>都是OCaml中的保留字，所以它们不能被用作标签。另外你也不能有
 <code>~from/~to</code> 或者<code>~start/~end</code>）。</p>
<p>之前<code>range</code>函数的类型是：</p>
<pre><code class="ocaml">range : int -&gt; int -&gt; int list</code></pre>

<p>而这个新的<code>range</code>函数的类型是：</p>
<pre><code class="ocaml">range : first:int -&gt; last:int -&gt; int list</code></pre>

<p>（容易让人混淆的是，<code>~</code><em>不会</em>在类型中出现，但是你要在所有地方上用到它）。</p>
<p>有了标签化参数，你再也不用按顺序传入参数了：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">range ~first:1 ~last:10</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">range ~last:10 ~first:1</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</span></code></pre>

<p>另外还有一个速写方式来命名参数，使得标签和变量名一样。下面是一个定义在
 <code>lablgtk/gaux.ml</code> 里的函数（这是一个lablgtk中用来干奇怪事情的库）：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">may</span> <span class="ocaml-variable">~f x </span>=
    <span class="keyword">match</span> x <span class="keyword">with</span>
    | None -&gt; ()
    | Some x -&gt; ignore(f x)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val may : f:('a -&gt; 'b) -&gt; 'a option -&gt; unit = &lt;fun&gt;
</span></code></pre>

<p>我们应该花点实现搞清楚这个函数在干些什么，并且手动地弄清楚这个函数的类型。首先，<code>~f</code>是
<code>~f:f</code>的简写（也就是说标签名和参数名都是<code>f</code>），然后这个函数有两个参数，其中第二个<code>x</code>是
没有标签的。OCaml允许部分参数标签化的函数。</p>
<p>那么<code>f</code>的类型是什么呢？显然的是它是一个函数。</p>
<p>那<code>x</code>的类型呢？<code>match</code>语句给出了提示，它是 <code>&#39;a option</code>。</p>
<p>这告诉我们 <code>f</code> 接收一个 <code>&#39;a</code> 参数，并且其返回值被忽略，因此它可以是任何类型。所以<code>f</code>的
类型是<code>&#39;a -&gt; &#39;b</code>。</p>
<p><code>may</code> 函数返回 <code>unit</code>，因为每个<code>match</code>的分支都返回<code>()</code>。</p>
<p>因此<code>may</code>的类型是（你可以在toplevel中验证：</p>
<pre><code class="ocaml">may : f:('a -&gt; 'b) -&gt; 'a option -&gt; unit</code></pre>

<p>这个函数是干什么的？运行它可以告诉我们些什么：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">may ~f:print_endline None</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : unit = ()
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">may ~f:print_endline (Some <span class="string">&quot;hello&quot;</span>)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">hello
</span><span class="ocaml-stderr"></span>- : unit = ()
</span></code></pre>

<p>如果未标签化的参数是一个“空指针”，那么它什么也不干，否则，<code>f</code>会被调用到它上。为什么
它会有用？我们会知道的。</p>
<h3 id="">可选参数</h3><p>可选参数和标签化参数类似。但是我们用<code>?</code>而不是<code>~</code>。下面是一个例子：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">?(step=1) a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> []
    <span class="keyword">else</span> a :: range ~step (a+step) b</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : ?step:int -&gt; int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>这个又<code>?</code>又<code>~</code>的语法比较容易让人混淆。我们会在下一节讨论这个内容。下面是你调用这个函数的方式：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">range 1 10</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">range 1 10 ~step:2</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [1; 3; 5; 7; 9]
</span></code></pre>

<p>这里， <code>?(step=1)</code> 明显就是 <code>~step</code> 是一个可选参数，并且它的默认值是1。我们也可以忽略默认值
直接传入可选参数。下面是一个改自lablgtk的例子：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">window</span> = { <span class="keyword">mutable</span> title: string;
                  <span class="keyword">mutable</span> width: int;
                  <span class="keyword">mutable</span> height: int }
    
  <span class="governing">let</span> <span class="ocaml-function">create_window</span> <span class="ocaml-variable">() </span>=
    { title = <span class="string">&quot;none&quot;</span>; width = 640; height = 480; }
    
  <span class="governing">let</span> <span class="ocaml-function">set_title</span> <span class="ocaml-variable">window title </span>=
    window.title &lt;- title
    
  <span class="governing">let</span> <span class="ocaml-function">set_width</span> <span class="ocaml-variable">window width </span>=
    window.width &lt;- width
    
  <span class="governing">let</span> <span class="ocaml-function">set_height</span> <span class="ocaml-variable">window height </span>=
    window.height &lt;- height
    
  <span class="governing">let</span> <span class="ocaml-function">open_window</span> <span class="ocaml-variable">?title ?width ?height () </span>=
    <span class="governing">let </span><span class="ocaml-variable">window</span> = create_window () <span class="governing">in</span>
    may ~f:(set_title window) title;
    may ~f:(set_width window) width;
    may ~f:(set_height window) height;
    window</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type window = {
  mutable title : string;
  mutable width : int;
  mutable height : int;
}
val create_window : unit -&gt; window = &lt;fun&gt;
val set_title : window -&gt; string -&gt; unit = &lt;fun&gt;
val set_width : window -&gt; int -&gt; unit = &lt;fun&gt;
val set_height : window -&gt; int -&gt; unit = &lt;fun&gt;
val open_window :
  ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; unit -&gt; window = &lt;fun&gt;
</span></code></pre>

<p>这个例子有点复杂难懂，不过这个模式在lablgtk的源代码中是很常见的。让我们先来看看 <code>create_window</code>。
这个函数接收一个<code>unit</code>并且返回一个<code>window</code>，并且初始化标题和宽高：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">create_window ()</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : window = {title = &quot;none&quot;; width = 640; height = 480}
</span></code></pre>

<p> <code>set_title</code>, <code>set_width</code> 和 <code>set_height</code> 是 <code>window</code> 的setter，是非纯的。比如说：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">w</span> = create_window () <span class="governing">in</span>
  set_title w <span class="string">&quot;My Application&quot;</span>;
  w</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : window = {title = &quot;My Application&quot;; width = 640; height = 480}
</span></code></pre>

<p>这里为止，都是之前提到的指令式的可变record。但是麻烦的地方是 <code>open_window</code> 函数。
这个函数接收<em>4</em>个参数，但是3个是可选的，一个<code>unit</code>是必需的。让我们来看看这个函数的调用：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">open_window ~title:<span class="string">&quot;My Application&quot;</span> ()</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : window = {title = &quot;My Application&quot;; width = 640; height = 480}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">open_window ~title:<span class="string">&quot;Clock&quot;</span> ~width:128 ~height:128 ()</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : window = {title = &quot;Clock&quot;; width = 128; height = 128}
</span></code></pre>

<p>它竟然工作了！这里的原因是<code>may</code>函数，而且这些可选参数没有默认值。</p>
<p>当一个可选参数没有默认值的时候，它的类型是 <code>&#39;a option</code>。
 <code>&#39;a</code> 会被类型推导，所以这里<code>?title</code>是<code>string option</code>。</p>
<p>到这里<code>may</code>发挥作用了，它接受一个函数和一个参数，当参数不是<code>None</code>的时候，它会作为参数调用
那个函数，因此：</p>
<pre><code class="ocaml">may ~f:(set_title window) title;</code></pre>

<p>如果<code>title</code>没有传入，那么它就是<code>None</code>，所以<code>may</code>不会做任何事，但是假如我们：</p>
<pre><code class="ocaml">open_window ~title:<span class="string">&quot;My Application&quot;</span> ()</code></pre>

<p>那么 <code>title</code> = <code>Some &quot;My Application&quot;</code>，而 <code>may</code> 会调用
<code>set_title window &quot;My Application&quot;</code>。</p>
<p>在你看下一节之前，你最好先完全弄懂这一节在说什么。</p>
<h3 id="quot-Warning-This-optional-argument-cannot-be-erased-quot">&quot;Warning: This optional argument cannot be erased&quot;</h3><p>我们已经接触到了标签和可选函数，但是就算是这么短的解释也会带来很多问题。第一个可能是
为什么 <code>open_window</code> 会需要一个多余的<code>unit</code>参数？让我们来试试去掉这个参数来定义：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">open_window</span> <span class="ocaml-variable">?title ?width ?<span class="ocaml-error-loc">height</span> </span>=
    <span class="governing">let </span><span class="ocaml-variable">window</span> = create_window () <span class="governing">in</span>
    may ~f:(set_title window) title;
    may ~f:(set_width window) width;
    may ~f:(set_height window) height;
    window</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr">Warning 16: this optional argument cannot be erased.
</span>val open_window : ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; window =
  &lt;fun&gt;
</span></code></pre>

<p>虽然OCaml编译了这个函数，但是它对<code>?height</code>产生了一个臭名昭著的警告：
 &quot;This optional argument cannot be erased&quot;。我们来看看调用这个函数 <code>open_window</code> 会发生什么：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">open_window</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; window = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">open_window ~title:<span class="string">&quot;My Application&quot;</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : ?width:int -&gt; ?height:int -&gt; window = &lt;fun&gt;
</span></code></pre>

<p>这段代码再也不工作了。实际上<code>open_window</code>根本没被调用，却打印了莫名其妙的信息，为什么呢？</p>
<p>回忆起 currying 和 uncurrying 和部分函数应用,比如说我们定义了<code>plus</code>函数：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">plus</span> <span class="ocaml-variable">x y </span>=
    x + y</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val plus : int -&gt; int -&gt; int = &lt;fun&gt;
</span></code></pre>

<p>我们可以部分应用这个函数 <code>plus 2</code>，这是一个把某个数字+2的函数：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">f</span> = plus 2</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val f : int -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">f 5</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 7
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">f 100</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 102
</span></code></pre>

<p>在<code>plus</code>的例子，OCaml编译器可以容易地知道<code>plus 2</code>没有足够的参数，它需要另一个参数才能被执行。
所以<code>plus 2</code>无疑是一个函数（译注：从语言的角度上，科里化的函数定义是一连串的嵌套lambda表达式）。</p>
<p>但是随着可选参数的加入，事情就不那么清楚了。 <code>open_window;;</code> 到底是指函数本身呢，还是
准备要调用，还是说需要什么参数呢？</p>
<p>OCaml很小心地处理了它，并没有调用这个函数，而是把它作为函数来返回。</p>
<p>让我们回到原来<code>unit</code>在最后的 <code>open_window</code>的定义：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">open_window</span> <span class="ocaml-variable">?title ?width ?height () </span>=
    <span class="governing">let </span><span class="ocaml-variable">window</span> = create_window () <span class="governing">in</span>
    may ~f:(set_title window) title;
    may ~f:(set_width window) width;
    may ~f:(set_height window) height;
    window</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val open_window :
  ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; unit -&gt; window = &lt;fun&gt;
</span></code></pre>

<p>如果你想传入可选参数，你必须在<code>unit</code>前传入，因而你可以：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">open_window ()</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : window = {title = &quot;none&quot;; width = 640; height = 480}
</span></code></pre>

<p>这里你肯定是想要用缺省设置调用这个函数，而：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">open_window</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : ?title:string -&gt; ?width:int -&gt; ?height:int -&gt; unit -&gt; window = &lt;fun&gt;
</span></code></pre>

<p>你则是</p>
<h3 id="">更多<code>~</code>简写</h3><p>让我们重写一遍<code>range</code>函数，这次我们要尽可能地用简写：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">~first ~last </span>=
    <span class="keyword">if</span> first &gt; last <span class="keyword">then</span> []
    <span class="keyword">else</span> first :: range ~first:(first+1) ~last</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : first:int -&gt; last:int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>记得 <code>~foo</code> 的意思是 <code>~foo:foo</code>。这适用于函数定义和函数调用，因此这里 <code>~last</code> 是
<code>~last:last</code>的简写。</p>
<h3 id="foo">函数调用中的 <code>?foo</code></h3><p>可选参数还有另一个很奇葩的地方。如果我们在某个函数中调用 <code>open_window</code> 来打开应用程序：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">open_application</span> <span class="ocaml-variable">?width ?height () </span><span class="ocaml-error-loc">=
    o</span>pen_window ~title:<span class="string">&quot;My Application&quot;</span> ~width ~height</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: This expression has type 'a option
       but an expression was expected of type int
</span></code></pre>

<p> <code>~width</code> 是 <code>~width:width</code> 的意思。但
<code>width</code> 的类型是 <code>&#39;a option</code> 而 <code>open_window ~width:</code> 需要一个 <code>int</code>。</p>
<p>OCaml为此提供了语法糖。在函数调用中写 <code>?width</code> 是 <code>~width:(unwrap width)</code> 的意思，
这里 <code>unwrap</code> 可以理解成是一个函数，用来去掉 <code>width</code> 的 <code>option</code> 包装（当然这只是说法上的，
实际上你不可能写出这个函数）。所以这个函数的正确定义是：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">open_application</span> <span class="ocaml-variable">?width ?height () </span>=
    open_window ~title:<span class="string">&quot;My Application&quot;</span> ?width ?height</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val open_application : ?width:int -&gt; ?height:int -&gt; unit -&gt; unit -&gt; window =
  &lt;fun&gt;
</span></code></pre>

<h3 id="">什么时候该用和不该用 <code>~</code> 和 <code>?</code></h3><p>标签和可选参数的语法想让难理解，你可能会想问什么时候用 <code>~foo</code>，什么时候用 <code>?foo</code>，
什么时候用 <code>foo</code>。实践上，这可以算是一种黑艺术。</p>
<p><code>?foo</code> 只在参数声明的时候用：</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">?arg1 ... </span>=</code></pre>

<p>或者当你想要去掉<code>option</code>包装的时候：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">open_application</span> <span class="ocaml-variable">?width ?height () </span>=
    open_window ~title:<span class="string">&quot;My Application&quot;</span> ?width ?height</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val open_application : ?width:int -&gt; ?height:int -&gt; unit -&gt; unit -&gt; window =
  &lt;fun&gt;
</span></code></pre>

<p><code>?foo</code> 的声明创建了一个叫 <code>foo</code> 的变量，所以当你需要 <code>?foo</code>的值时，你用 <code>foo</code>。</p>
<p>标签也一样， <code>~foo</code> 出现在函数的声明:</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">~foo:foo ... </span>=</code></pre>

<p><code>~foo:foo</code> 的声明创建了一个叫 <code>foo</code> 的变量，所以当你需要它的值是你直接用 <code>foo</code>。</p>
<p>但是事情因为两个原因而变得复杂起来：1. <code>~foo</code> 简写(等价于 <code>~foo:foo</code>)和，2.你在函数
调用中使用到了这个简写。</p>
<p>下面是lablgtk中的一些晦涩的代码：</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">html</span> <span class="ocaml-variable">?border_width ?width ?height ?packing ?show () </span>=  <span class="comment">(* line 1 *)</span>
  <span class="governing">let </span><span class="ocaml-variable">w</span> = create () <span class="governing">in</span>
  load_empty w;
  <span class="ocaml-module">Container</span>.set w ?border_width ?width ?height;            <span class="comment">(* line 4 *)</span>
  pack_return (<span class="keyword">new</span> html w) ~packing ~show                  <span class="comment">(* line 5 *)</span></code></pre>

<p>第一行是函数定义，注意到定义了5个可选参数，第六个参数 <code>unit</code>是必需的。每个可选参数都定义
了一个变量，比如 <code>border_width</code> 的类型是 <code>&#39;a option</code>。</p>
<p>第四行我们以 <code>?foo</code> 的形式向函数调用传入了可选传入。 <code>Container.set</code> 有下面这个类型：</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Container</span> <span class="ocaml-variable"></span>= <span class="governing">struct</span>
  <span class="governing">let</span> <span class="ocaml-function">set</span> <span class="ocaml-variable">?border_width ?(width = -2) ?(height = -2) w </span>=
    <span class="comment">(* ... *)</span></code></pre>

<p>第五行用的是 <code>~</code> 简写，展开如下：</p>
<pre><code class="ocaml">pack_return (<span class="keyword">new</span> html w) ~packing:packing ~show:show</code></pre>

<p> <code>pack_return</code> 传入了以 <code>~packing</code> 和 <code>~show</code> 传入了标签化参数，他们的类型都是
<code>&#39;a option</code>。也就是说<code>pack_return</code> 手动去掉了 <code>option</code> 的包装。</p>
<h3 id="">附录</h3><p>如果你觉得标签和可选参数很复杂，没错，他们就这么复杂。不过幸运的是，这是比较新的特性，
除了lablgtk以外基本不太可能看到它们的用法。</p>
<h2 id="">多态变体</h2><p>试一下编译下面的代码：</p>
<pre class="C"><code class="C">#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

enum lock { open, close };

main ()
{
  int fd, n;
  char buffer[256];

  fd = open (&quot;/etc/motd&quot;, O_RDONLY);                     // line 12
  while ((n = read (fd, buffer, sizeof buffer)) &gt; 0)
    write (1, buffer, n);
  close (fd);                                            // line 15
}</code></pre><p>当我编译这段代码的时候我有如下的错误：</p>
<pre class="text"><code class="text">test.c: In function `main&#39;:
test.c:12: error: called object is not a function
test.c:15: error: called object is not a function</code></pre>

<p>译注：我的gcc 4.7.2报错不太一样：</p>
<pre><code>test2.c:5:13: error: ‘open’ redeclared as different kind of symbol
In file included from test2.c:2:0:
/usr/include/fcntl.h:119:12: note: previous declaration of ‘open’ was here
test2.c:5:19: error: ‘close’ redeclared as different kind of symbol
In file included from test2.c:3:0:
/usr/include/unistd.h:350:12: note: previous declaration of ‘close’ was here
test2.c: In function ‘main’:
test2.c:12:16: error: called object ‘0’ is not a function
test2.c:15:13: error: called object ‘1’ is not a function</code></pre><p>实际上原著的报错不太合理，因为<code>lock</code>在尝试重新定义已经声明的符号。这有可能是比较老的编译器的行为。</p>
<p>这里展示了C的enum的一个问题，在这里，一个enum语句用到了三个符号，分别是
<code>lock</code>, <code>open</code> 和 <code>close</code>.。下面是另一个例子：</p>
<pre class="C"><code class="C">enum lock { open, close };
enum door { open, close };</code></pre><p>报错为：</p>
<pre class="text"><code class="text">test.c:2: error: conflicting types for `open&#39;
test.c:1: error: previous declaration of `open&#39;
test.c:2: error: conflicting types for `close&#39;
test.c:1: error: previous declaration of `close&#39;</code></pre><p>第一个enum定义了 <code>open</code> 是一个
<code>enum lock</code>，你不能用它来定义其它东西。</p>
<p>C/C++程序员对这很清楚，因此他们不会写这样的代码。但是OCaml也有类似的问题，但是它
用另一个方式来解决。</p>
<p>下面是OCaml的代码，而且是可以编译的：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">lock</span> = Open | Close
  <span class="governing">type</span> <span class="type">door</span> = Open | Close</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type lock = Open | Close
type door = Open | Close
</span></code></pre>

<p>在这两个代码之后，<code>Open</code>是什么类型呢？这很容易在toplevel中找到答案：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">lock</span> = Open | Close</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type lock = Open | Close
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">door</span> = Open | Close</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type door = Open | Close
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">Open</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : door = Open
</span></code></pre>

<p>OCaml会用最新的 <code>Open</code>，也就是<code>door</code>。这也不是什么很大的问题，因为如果你在<code>lock</code>的
上下文处用了<code>Open</code>，你的代码不可能通过类型推导的。</p>
<p>目前为止，这和C比较类似。现在我要告诉你OCaml提供了一种方式来绕开<code>Open</code>只有一种类型的限制。
也就是说，当我用到 <code>Open</code> 的时候，OCaml应该自己去搞清楚我需要的是
<code>lock</code> 版本的还是 <code>door</code> 版本的。</p>
<p>实现的语法有点不一样:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">lock</span> = [ `Open | `Close ]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type lock = [ `Close | `Open ]
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">door</span> = [ `Open | `Close ]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type door = [ `Close | `Open ]
</span></code></pre>

<p>注意到这个语法不同的地方：</p>
<ol><li>变体的名字有一个 <code>`</code> （反引号）</li><li>你要用方括号括住子类型。</li></ol>

<p>那么问题自然就变成了：<code>`Open</code> 究竟是什么类型？</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">`Open</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : [&gt; `Open ] = `Open
</span></code></pre>

<p><code>[&gt; `Open]</code> 可以读作
<code>[ `Open | 和一些我们不知道的可能性 ]</code>.
大于号的意思是这个可能性比所列出的要多（译注：这段话太模糊了，Java码农可以试一下类比PECS。C#码农
可以类比covariance 和 contravariance ，泛型声明的+-号。在这个特定的例子，这可以理解为“至少包含<code>`Open</code>
constructor的某个类型”。本质上，这些设计都是为了克服语言类型系统
本身的限制。现在流行语言的类型系统往往都是sound但不是complete的，因此虽然它返回的结果总是正确的，
但却会对一些我们觉得是正确的类型关系上报错，虽然有些关系在人类语义上是成立的，但是类型分析未必可以理解。
举个例子，比方说<code>Generic&lt;Base&gt; var = new Generic&lt;Derived&gt;();</code>就会报错。
而一些比较简单的语言的选择是放弃这种经典的静态类型系统而采用动态类型，如Python。深入理解请参考计算机语言，编译器，自动机相关书籍）。</p>
<p> <code>`Open</code> 本身并没有什么特别的。 <em>任何</em> 带反引号的单词都可以用作类型，包括一些我们之前没有提到过的：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">`Foo</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : [&gt; `Foo ] = `Foo
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">`Foo 42</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : [&gt; `Foo of int ] = `Foo 42
</span></code></pre>

<p>让我们来编写一个打印 <code>lock</code> 状态的函数：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">print_lock</span> <span class="ocaml-variable">st </span>=
    <span class="keyword">match</span> st <span class="keyword">with</span>
    | `Open -&gt; print_endline <span class="string">&quot;The lock is open&quot;</span>
    | `Close -&gt; print_endline <span class="string">&quot;The lock is closed&quot;</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val print_lock : [&lt; `Close | `Open ] -&gt; unit = &lt;fun&gt;
</span></code></pre>

<p>注意看这个函数的类型，类型推导知道<code>st</code>参数的类型是 <code>[&lt; `Close | `Open]</code>。
这个小于号是指这个类型是一个 __关闭的类__。 也就是说这个函数只会应用到 <code>`Close</code> 或者 <code>`Open</code>
上而不能是其他。</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">print_lock `Open</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">The lock is open
</span><span class="ocaml-stderr"></span>- : unit = ()
</span></code></pre>

<p>译者补充例子：请先参照我上面的注加深一下对类型系统的理解。这里的小于号是由于<code>match</code>语句
必须匹配所有情况这个特点推导出的。聪明的读者应该已经可以举一反三，知道如何把这个
小于号变成大于号：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">print_lock2</span> <span class="ocaml-variable">st </span>=
    <span class="keyword">match</span> st <span class="keyword">with</span>
    | `Open -&gt; <span class="string">&quot;open&quot;</span>
    | `Close -&gt; <span class="string">&quot;close&quot;</span>
    | _ -&gt; <span class="string">&quot;abc&quot;</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val print_lock2 : [&gt; `Close | `Open ] -&gt; string = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">print_lock2 `A</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : string = &quot;abc&quot;
</span></code></pre>

<p>注意到<code>print_lock</code>对于 <code>door</code> 和<code>lock</code> 一样工作！我们已经一定程度上地放弃了类型推导，
只用来猜测我们的意图，而不是趋使我们写类型正确的代码。</p>
<p>这只是一个简介。由于类型安全会被降低，因此你最好还是别用。但是你有机会在一些高级的OCaml代码中
看到这个用法，因为一个高手往往不希望被彻底束缚。</p>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	
<div class="column">
  <div class="entry">
    <h1><a href="../../learn/">Learn</a></h1>
    <ul>
      <li><a href="../../learn/taste.html">Code Examples</a></li>
      <li><a href="../../learn/tutorials/index.zh.html">Tutorials</a></li>
      <li><a href="../../learn/books.html">Books</a></li>
      <li><a href="../../learn/success.html">Success Stories</a></li>
      <li><a href="."></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../docs/">Documentation</a></h1>
    <ul>
      <li><a href="../../docs/install.html">Install</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manual</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Packages</a></li>
      <li><a href="../../releases/index.html">Compiler Releases</a></li>
      <li><a href="../../docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../community/">Community</a></h1>
    <ul>
      <li><a href="../../community/mailing_lists.html">Mailing Lists</a></li>
      <li><a href="../../meetings/">Meetings</a></li>
      <li><a href="../../community/planet/">News</a></li>
      <li><a href="../../community/support.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Bug Tracker</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Website</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/labels.zh.md" target="_blank">Edit this page</a></li>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Website Issues</a></li>
      <li><a href="../../about.html">About This Site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Find Us on GitHub</a></li>
      <li><a href="../../contributors.html">Credits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js" type="text/javascript"></script>

     

  </body>
</html>
