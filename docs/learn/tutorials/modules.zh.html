<!DOCTYPE HTML>


<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
  <head>
    <meta charset="utf-8"/>
    
    <link href="modules.html" rel="alternate" hreflang="en"/>
<link href="modules.fr.html" rel="alternate" hreflang="fr"/>
<link href="modules.ja.html" rel="alternate" hreflang="ja"/>
<link href="modules.ko.html" rel="alternate" hreflang="ko"/>
<link href="modules.zh.html" rel="alternate" hreflang="zh"/>

    
    <title>Modules &#8211; OCaml</title>
    <link href="../../img/favicon32x32.ico?" rel="shortcut icon" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <link href="//fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css"/>
    
    <link href="../../css/bootstrap.css" rel="stylesheet" media="screen"/>
    <link href="../../css/bootstrap_mod.css" rel="stylesheet" media="screen"/>
    <link href="../../css/ocamlorg.css" rel="stylesheet" media="screen"/>
    
    
    <script src="../../js/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="../../" class="brand"><img src="../../img/colour-logo-white.svg" class="svg" alt="OCaml"/><img src="../../img/colour-logo-white.png" class="png" alt="OCaml"/></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="../../learn/">Learn</a></li>
              <li><a href="../../docs/">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Packages</a></li>
              <li><a href="../../community/">Community</a></li>
              <li><a href="../../community/planet/">News</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/modules.zh.md" title="Edit this page" class="edit-this-page pull-right"><span>Edit this page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input type="hidden" name="as_sitesearch" value="ocaml.org"/>
              <input placeholder="Search" class="search-query" name="q" type="text"/>
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="../../">Home</a><span class="divider"></span></li>
<li><a href="../../learn/">Learn</a><span class="divider"></span></li>
<li><a href="../../learn/tutorials/index.zh.html">OCaml教程</a><span class="divider"></span></li>
<li class="active">Modules</li>


    </ol>
    <ul class="translations">
      <li><a href="modules.html">en</a></li>
<li><a href="modules.fr.html">fr</a></li>
<li><a href="modules.ja.html">日本語</a></li>
<li><a href="modules.ko.html">한국어</a></li>
<li class="active">中文</li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contents</a></li>
          <ul><li><a href="#">基本用法</a>
</li><li><a href="#Interfaces-Signatures">接口(Interfaces)和签名(Signatures)</a>
</li><li><a href="#Abstract-Types">抽象类型(Abstract Types)</a>
</li><li><a href="#Submodules">子模块(Submodules)</a>
<ul><li><a href="#">模块实现</a>
</li><li><a href="#">子模块接口</a>
</li></ul>
</li><li><a href="#Functors">函子（Functors，也作仿函数)</a>
<ul><li><a href="#">什么是函子，为什么需要它们？</a>
</li><li><a href="#">怎么使用现存的函子？</a>
</li><li><a href="#">怎么定义函子？</a>
</li></ul>
</li><li><a href="#">模块实际操作</a>
<ul><li><a href="#">显示模块接口</a>
</li><li><a href="#">模块包含</a>
</li></ul>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        

<h1 id="">模块</h1>

<h2 id="">基本用法</h2><p>在OCaml中， 每一段代码都被包成一个模块。一个模块可以选择性地作为另外一个模块的子模块，很像文件系统中的目录-但是我们不经常这样做。</p>
<p>当你写一个程序使用两个文件<code>amodule.ml</code>和<code>bmodule.ml</code>，它们中的每一个都自动定义一个模块，名字叫<code>Amodule</code>和<code>Bmodule</code>，模块的内容就是你写到文件中的东西。</p>
<p>这里是文件<code>amodule.ml</code>里面的代码：</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">&quot;Hello&quot;</span></code></pre>

<p>还有<code>bmodule.ml</code>里面的：</p>
<pre><code class="ocaml"><span class="ocaml-module">Amodule</span>.hello ()</code></pre>

<p>通常文件一个一个编译，让我们来编译：</p>
<pre class="shell"><code class="shell">ocamlopt -c amodule.ml
ocamlopt -c bmodule.ml
ocamlopt -o hello amodule.cmx bmodule.cmx</code></pre>

<p>现在我们有一个很好的可执行文件用来打印 “Hello”。如你所见，如果你要访问一个给定模块的任何东西，你要用模块的名字（通常是大写字母开头）后面跟一个点号，然后是你要用的东西。可能是一个值，一个类型构造器，或者是给定模块能提供的任何东西。</p>
<p>程序库，包括标准库，提供模块的集合。比如，<code>List.iter</code>表示<code>List</code>模块中的<code>iter</code>函数。</p>
<p>好了，如果你正在大量使用一个给定的模块，你可以使这个模块的内容直接可以访问。我们要使用<code>open</code>指令来达到这个目的。在我们的例子中，<code>bmodule.ml</code>可以写成这样：</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Amodule</span><span class="ocaml-prompt">;;</span><br/>hello ();;</code></pre>

<p>注意，人们倾向于避免使用丑陋的“;;”，所以这样写更加普遍：</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Amodule</span>
<span class="governing">let</span> () =
  hello ()</code></pre>

<p>不管怎样，用不用<code>open</code>是个人选择的问题。一些模块使用了很多很普遍的名字。<code>List</code>模块就是这样的例子。通常我们不用<code>open List</code>。像<code>Printf</code>的其他模块，提供通常不受冲突的名字，比如<code>printf</code>。为了避免到处写<code>Printf.printf</code>，在文件开头放一句<code>open Printf</code>是有道理的。</p>
<p>以下是一个简短的例子（在toplevel中）。</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">open</span> <span class="ocaml-module">Printf</span>
  <span class="governing">let </span><span class="ocaml-variable">my_data</span> = [ <span class="string">&quot;a&quot;</span>; <span class="string">&quot;beautiful&quot;</span>; <span class="string">&quot;day&quot;</span> ]
  <span class="governing">let</span> () = <span class="ocaml-module">List</span>.iter (<span class="keyword">fun</span> s -&gt; printf <span class="string">&quot;%s\n&quot;</span> s) my_data</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">a
beautiful
day
</span><span class="ocaml-stderr"></span>val my_data : string list = [&quot;a&quot;; &quot;beautiful&quot;; &quot;day&quot;]
</span></code></pre>

<h2 id="Interfaces-Signatures">接口(Interfaces)和签名(Signatures)</h2><p>一个模块可以给其他程序提供很多功能（函数，类型，子模块，……）。如果没有什么特别指定，在模块中定义的一切可以从外部访问。这么做在小程序中是一般可以的，但是在很多情况下，一个模块更应该只提供一系列有限（但是有用的）接口，而隐藏一些辅助的函数和类型。</p>
<p>为此，我们得定义模块接口，掩盖模块的实现细节。就像模块从 .ml 文件得到，相应的模块接口或者叫签名从 .mli 文件得到。它包含了一个带有类型的值的列表，及其他。以下重新实现<code>amodule.ml</code>。</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">&quot;Hello&quot;</span>
<span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message</code></pre>

<p>事实上，<code>Amodule</code>有下面的接口：</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">message</span> : string
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit</code></pre>

<p>假设不想让其他模块直接访问<code>message</code>，我们需要定义一个严格的接口来隐藏它。这是我们的<code>amodule.mli</code>文件。</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="comment">(** &#26174;&#31034;&#19968;&#21477;&#38382;&#20505;&#28040;&#24687;&#12290; *)</span></code></pre>

<p>(注意，使用<a href="../../releases/4.10/htmlman/ocamldoc.html">ocamldoc</a>支持的格式来写 .mli 文件的文档是个好习惯。)</p>
<p>.mli 文件必须在对应的 .ml 文件之前编译。它们用<code>ocamlc</code>来编译，而 .ml 文件用<code>ocamlopt</code>来编译成原生码。</p>
<pre class="shell"><code class="shell">ocamlc -c amodule.mli
ocamlopt -c amodule.ml
...</code></pre>

<h2 id="Abstract-Types">抽象类型(Abstract Types)</h2><p>类型定义是怎么样的呢？我们已经看到值可以通过把它们的名字和类型放到 .mli 文件的方式来导出。</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit</code></pre>

<p>但是模块经常定义新的类型。让我们来定义一个简单的record类型，用来表达一个日期。</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span> = { day : int;  month : int;  year : int }</code></pre>

<p>有四个选择编写 .mli 文件:</p>
<ol><li>类型在签名中完全忽略</li><li>把类型定义拷贝到签名</li><li>类型做成抽象的：只给出名字</li><li>record的域做成只读的：<code>type date = private { ... }</code></li></ol>

<p>在第3种情况中，应该是下面代码这样：</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span></code></pre>

<p>现在，这个模块的用户能操作<code>date</code>类型的对象，但是他们不能直接访问record的域，他们必须使用模块提供的函数。假设这个模块提供三个函数，一个用来创建一个日期，一个用来计算两个日期之间的间隔，还有一个用年的形式返回一个日期。</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span>
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">create</span> : ?days:int -&gt; ?months:int -&gt; ?years:int -&gt; unit -&gt; date
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">sub</span> : date -&gt; date -&gt; date
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">years</span> : date -&gt; float</code></pre>

<p>只有<code>create</code>和<code>sub</code>才能用来创建<code>date</code>record。因此，这个模块的用户不可能创建不规范的record。实际上，我们的实现使用record，但是我们可以修改它，并且确保不破坏任何依赖这个模块的代码！这在一个库中很重要，同一个库之后的版本能够暴露同样的接口，同时可以内部改变实现，包括数据结构。</p>
<h2 id="Submodules">子模块(Submodules)</h2>

<h3 id="">模块实现</h3>

<p><code>example.ml</code>文件自身就可以代表<code>Example</code>模块。其模块签名是所有定义的符号，又或者可以用一个<code>example.mli</code>文件来约束它。</p>
<p>一个给定的模块也可以在一个文件中显式地定义，成为当前模块的一个子模块。让我们来看看<code>example.ml</code>文件：</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>= <span class="governing">struct</span>
  <span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">&quot;Hello&quot;</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message
<span class="governing">end</span>
<span class="governing">let</span> <span class="ocaml-function">goodbye</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">&quot;Goodbye&quot;</span>
<span class="governing">let</span> <span class="ocaml-function">hello_goodbye</span> <span class="ocaml-variable">() </span>=
  <span class="ocaml-module">Hello</span>.hello ();
  goodbye ()</code></pre>

<p>从另一个文件中可以看出，很明显我们有两个层次的模块。我们可以这样写：</p>
<pre><code class="ocaml"><span class="governing">let</span> () =
  <span class="ocaml-module">Example</span>.<span class="ocaml-module">Hello</span>.hello ();
  <span class="ocaml-module">Example</span>.goodbye ()</code></pre>

<h3 id="">子模块接口</h3>

<p>我们可以约束一个给定子模块的接口，这叫做模块类型（Module Types）。我们在<code>example.ml</code>文件中做一下：</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>: <span class="governing">sig</span>
 <span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="governing">end</span> = 
<span class="governing">struct</span>
  <span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">&quot;Hello&quot;</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message
<span class="governing">end</span>
  
<span class="comment">(* &#22312;&#36825;&#37324; <span class="ocaml-module">Hello</span>.message &#19981;&#20877;&#33021;&#34987;&#35775;&#38382;&#12290; *)</span>
<span class="governing">let</span> <span class="ocaml-function">goodbye</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">&quot;Goodbye&quot;</span>
<span class="governing">let</span> <span class="ocaml-function">hello_goodbye</span> <span class="ocaml-variable">() </span>=
  <span class="ocaml-module">Hello</span>.hello ();
  goodbye ()</code></pre>

<p>上面<code>Hello</code>模块的定义和写一对<code>hello.mli</code>/<code>hello.ml</code>文件是等价的。把所有东西写在一个代码块里面是不优雅的，所以我们一般选择单独定义模块签名。</p>
<pre><code class="ocaml"><span class="governing">module <span class="governing">type</span></span> <span class="ocaml-module">Hello_type</span> <span class="ocaml-variable"></span>= <span class="governing">sig</span>
 <span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="governing">end</span>
  
<span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>: <span class="ocaml-module">Hello_type</span> = <span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p><code>Hello_type</code>是一个命名的模块类型，并且可以重用，用来定义其他的模块接口。</p>
<p>虽然子模块在一些情况下可能有用，但是它们和函子一起用的时候效果比较明显。这个下一部分讲。</p>
<h2 id="Functors">函子（Functors，也作仿函数)</h2><p>函子可能是OCaml中最复杂的特性之一，但是你想成为一个成功的OCaml程序员不需要大量地使用函子。实际上，你可能从来不用自己定义一个函子，不过你确实会在标准库中遇到它们。函子是使用 Set 和 Map 模块的唯一途径，不过使用它们并不困难。</p>
<p>译注：如果你对C衍生的语言比较熟悉而对函数式语言所知甚少，那么可能会对这里的Functors有所误会。在C++，C#，Java都有能够被称作Functor的东西，分别是括号操作符重载，委托（delegate），匿名内部类。但是这里的Functors更加接近lambda表达式，而不是Ocaml中的模块化参数。</p>
<h3 id="">什么是函子，为什么需要它们？</h3><p>函子是用另一个模块来参数化的模块，就像函数是用其他的值，也就是参数，来参数化的值一样。</p>
<p>基本上，函子允许传入一个类型作为参数，这个在OCaml中直接做是不可能地。比如说，我们可以定义一个函子接受一个整数 n，返回一系列只能用在长度为 n 的数组上的操作。如果程序员犯错误，把一个常规的数组传给这些操作，则会造成编译错误。如果我们不是使用这个函子，而是标准数组类型，编译器就不能识别出错误，我们将在未来不确定时刻得到运行时错误，这样会更加糟糕。</p>
<h3 id="">怎么使用现存的函子？</h3><p>标准库定义了<code>Set</code>模块，它提供了一个<code>Make</code>函子。这个函子接受一个参数，这个参数是一个提供两样东西的模块：用<code>t</code>来给出的元素类型，和用<code>compare</code>给出的比较函数。这个函子的重点是即使程序员犯错误也确保同样的比较函数总是被使用。</p>
<p>举个例子，如果我们要使用整型的集合，我们将会这样做：</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Int_set</span> <span class="ocaml-variable"></span>= <span class="ocaml-module">Set</span>.Make (<span class="governing">struct</span>
                             <span class="governing">type</span> <span class="type">t</span> = int
                             <span class="governing">let </span><span class="ocaml-variable">compare</span> = compare
                           <span class="governing">end</span>)</code></pre>

<p>对于字符串的集合甚至更简单，因为标准库提供一个<code>String</code>模块，有一个类型<code>t</code>和一个函数<code>compare</code>。如果你仔细地看下来的话，到现在你肯定会猜怎么去创建一个用来操作字符串集合的模块。</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">String_set</span> <span class="ocaml-variable"></span>= <span class="ocaml-module">Set</span>.Make (String)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module String_set :
  sig
    type elt = String.t
    type t = Set.Make(String).t
    val empty : t
    val is_empty : t -&gt; bool
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val singleton : elt -&gt; t
    val remove : elt -&gt; t -&gt; t
    val union : t -&gt; t -&gt; t
    val inter : t -&gt; t -&gt; t
    val disjoint : t -&gt; t -&gt; bool
    val diff : t -&gt; t -&gt; t
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val subset : t -&gt; t -&gt; bool
    val iter : (elt -&gt; unit) -&gt; t -&gt; unit
    val map : (elt -&gt; elt) -&gt; t -&gt; t
    val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a
    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool
    val exists : (elt -&gt; bool) -&gt; t -&gt; bool
    val filter : (elt -&gt; bool) -&gt; t -&gt; t
    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t
    val cardinal : t -&gt; int
    val elements : t -&gt; elt list
    val min_elt : t -&gt; elt
    val min_elt_opt : t -&gt; elt option
    val max_elt : t -&gt; elt
    val max_elt_opt : t -&gt; elt option
    val choose : t -&gt; elt
    val choose_opt : t -&gt; elt option
    val split : elt -&gt; t -&gt; t * bool * t
    val find : elt -&gt; t -&gt; elt
    val find_opt : elt -&gt; t -&gt; elt option
    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val of_list : elt list -&gt; t
    val to_seq_from : elt -&gt; t -&gt; elt Seq.t
    val to_seq : t -&gt; elt Seq.t
    val add_seq : elt Seq.t -&gt; t -&gt; t
    val of_seq : elt Seq.t -&gt; t
  end
</span></code></pre>

<p>(圆括号是必须的)</p>
<h3 id="">怎么定义函子？</h3><p>带有一个参数的函子可以这样来定义：</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>= <span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p><code>X</code>是作为参数被传递的模块，<code>X_type</code>是它的签名，这个是强制的。</p>
<p>返回模块的签名是可以被约束的，使用这样的语法：</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>: <span class="ocaml-module">Y_type</span> =
<span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p>或者在<code>.mli</code>文件中指定：</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>: Y_type</code></pre>

<p>一般来说，函子的语法理解起来比较困难。最好的方法可能是去看标准库中的源代码<code>set.ml</code>和<code>map.ml</code>。</p>
<p>结束语：函子是用来帮助程序员写出正确的程序的，而不是用来提高性能的，甚至会有运行时的损耗，除非使用像 ocamldefun 这样的解函器，ocamldefun 需要访问函子的源代码。</p>
<h2 id="">模块实际操作</h2>

<h3 id="">显示模块接口</h3><p>在<code>ocaml</code>的 toplevel 中，下面的技巧可以让一个现存的模块的内容可视化，比如<code>List</code>：</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">M</span> = <span class="ocaml-module">List</span>;;</code></pre>

<p>另外对于大多数的库有在线的文档，或者你可以使用 labltk（Ocaml的Tk图形用户界面） 做的<code>ocamlbrowser</code>。</p>
<h3 id="">模块包含</h3><p>如果我们觉得在标准的<code>List</code>模块中缺少一个函数，但是如果里面有我们确实需要它。在文件<code>extensions.ml</code>中，我们可以用<code>include</code>指令来实现这个效果。</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">List</span> <span class="ocaml-variable"></span>= <span class="governing">struct</span>
  <span class="governing">include</span> List
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">optmap</span> <span class="ocaml-variable">f </span>= <span class="keyword">function</span>
    | [] -&gt; []
    | hd :: tl -&gt;
       <span class="keyword">match</span> f hd <span class="keyword">with</span>
       | None -&gt; optmap f tl
       | Some x -&gt; x :: optmap f tl
<span class="governing">end</span></code></pre>

<p>它创建了<code>Extensions.List</code>模块，这个模块有标准的<code>List</code>模块的所有东西，加上一个新的<code>optmap</code>函数。从另一个文件看，要覆盖默认的<code>List</code>模块我们所要做的只是在 .ml 文件的开头<code>open Extensions</code></p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Extensions</span>
...
<span class="ocaml-module">List</span>.optmap ...</code></pre>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	
<div class="column">
  <div class="entry">
    <h1><a href="../../learn/">Learn</a></h1>
    <ul>
      <li><a href="../../learn/taste.html">Code Examples</a></li>
      <li><a href="../../learn/tutorials/index.zh.html">Tutorials</a></li>
      <li><a href="../../learn/books.html">Books</a></li>
      <li><a href="../../learn/success.html">Success Stories</a></li>
      <li><a href="."></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../docs/">Documentation</a></h1>
    <ul>
      <li><a href="../../docs/install.html">Install</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manual</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Packages</a></li>
      <li><a href="../../releases/index.html">Compiler Releases</a></li>
      <li><a href="../../docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../community/">Community</a></h1>
    <ul>
      <li><a href="../../community/mailing_lists.html">Mailing Lists</a></li>
      <li><a href="../../meetings/">Meetings</a></li>
      <li><a href="../../community/planet/">News</a></li>
      <li><a href="../../community/support.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Bug Tracker</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Website</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/modules.zh.md" target="_blank">Edit this page</a></li>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Website Issues</a></li>
      <li><a href="../../about.html">About This Site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Find Us on GitHub</a></li>
      <li><a href="../../contributors.html">Credits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js" type="text/javascript"></script>

     

  </body>
</html>
