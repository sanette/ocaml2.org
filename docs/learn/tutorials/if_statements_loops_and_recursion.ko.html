<!DOCTYPE HTML>


<html xmlns="http://www.w3.org/1999/xhtml" lang="ko" xml:lang="ko">
  <head>
    <meta charset="utf-8"/>
    
    <link href="if_statements_loops_and_recursion.html" rel="alternate" hreflang="en"/>
<link href="if_statements_loops_and_recursion.fr.html" rel="alternate" hreflang="fr"/>
<link href="if_statements_loops_and_recursion.it.html" rel="alternate" hreflang="it"/>
<link href="if_statements_loops_and_recursion.ja.html" rel="alternate" hreflang="ja"/>
<link href="if_statements_loops_and_recursion.ko.html" rel="alternate" hreflang="ko"/>
<link href="if_statements_loops_and_recursion.zh.html" rel="alternate" hreflang="zh"/>

    
    <title>If 문, 루프, 재귀 &#8211; OCaml</title>
    <link href="../../img/favicon32x32.ico?" rel="shortcut icon" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <link href="//fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css"/>
    
    <link href="../../css/bootstrap.css" rel="stylesheet" media="screen"/>
    <link href="../../css/bootstrap_mod.css" rel="stylesheet" media="screen"/>
    <link href="../../css/ocamlorg.css" rel="stylesheet" media="screen"/>
    
    
    <script src="../../js/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="../../" class="brand"><img src="../../img/colour-logo-white.svg" class="svg" alt="OCaml"/><img src="../../img/colour-logo-white.png" class="png" alt="OCaml"/></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="../../learn/">Learn</a></li>
              <li><a href="../../docs/">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Packages</a></li>
              <li><a href="../../community/">Community</a></li>
              <li><a href="../../community/planet/">News</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/if_statements_loops_and_recursion.ko.md" title="Edit this page" class="edit-this-page pull-right"><span>Edit this page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input type="hidden" name="as_sitesearch" value="ocaml.org"/>
              <input placeholder="Search" class="search-query" name="q" type="text"/>
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="../../">Home</a><span class="divider"></span></li>
<li><a href="../../learn/">Learn</a><span class="divider"></span></li>
<li><a href="../../learn/tutorials/index.ko.html">OCaml튜토리얼</a><span class="divider"></span></li>
<li class="active">If 문, 루프, 재귀</li>


    </ol>
    <ul class="translations">
      <li><a href="if_statements_loops_and_recursion.html">en</a></li>
<li><a href="if_statements_loops_and_recursion.fr.html">fr</a></li>
<li><a href="if_statements_loops_and_recursion.it.html">it</a></li>
<li><a href="if_statements_loops_and_recursion.ja.html">日本語</a></li>
<li class="active">한국어</li>
<li><a href="if_statements_loops_and_recursion.zh.html">中文</a></li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contents</a></li>
          <ul><li><a href="#if-if-expression">if 문 - 사실은 if 표현식(expression)</a>
</li><li><a href="#begin-end">begin ... end 사용하기</a>
</li><li><a href="#for-while">for 루프와 while 루프</a>
</li><li><a href="#">리스트를 따라 루프 돌기</a>
</li><li><a href="#">문자열을 따라 루프 돌기</a>
</li><li><a href="#recursion">재귀 호출 (recursion)</a>
<ul><li><a href="#1">방법 1</a>
</li><li><a href="#2">방법 2</a>
</li><li><a href="#3">방법 3</a>
</li><li><a href="#Addendum">Addendum</a>
</li><li><a href="#Recursion-example-maximum-element-in-a-list">Recursion example: maximum element in a list</a>
</li><li><a href="#Tail-recursion">Tail recursion</a>
</li></ul>
</li><li><a href="#Mutable-records-references-again-and-arrays">Mutable records, references (again!) and arrays</a>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        

<h1 id="If">If 문, 루프, 재귀</h1>

<h2 id="if-if-expression">if 문 - 사실은 if 표현식(expression)</h2>

<p>Ocaml은 다음 두가지 형태의 명백한 의미의 if 문이 있다:</p>
<pre><code class="ocaml"><span class="keyword">if</span> boolean-condition <span class="keyword">then</span> expression
  
<span class="keyword">if</span> boolean-condition <span class="keyword">then</span> expression <span class="keyword">else</span> other-expression</code></pre>

<p>여태까지 사용해왔던 다른 언어들과는 다르게, ocaml에서 if문은 진짜
표현식(expression)이다. Ocaml의 if문은 사실 다음과 더 비슷하다.
<code>boolean-condition ? expression :other-expression</code></p>
<p>다음은 if문의 간단한 예제이다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">max</span> <span class="ocaml-variable">a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> a <span class="keyword">else</span> b</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val max : 'a -&gt; 'a -&gt; 'a = &lt;fun&gt;
</span></code></pre>

<p>잠깐 위 예제를 OCaml 톱레벨에서 입력해 보면 이 함수가 아래의 타입인
다형적(polymorphic) 함수라는 것을 알 수 있다.</p>
<pre><code class="ocaml">max : 'a -&gt; 'a -&gt; 'a</code></pre>

<p>따라서 OCaml에서 위의 <code>max</code> 함수는 어떤 타입에도 사용할 수 있다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">max 3 5</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 5
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">max 3.5 13.0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : float = 13.
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">max <span class="string">&quot;a&quot;</span> <span class="string">&quot;b&quot;</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : string = &quot;b&quot;
</span></code></pre>

<p>이는 <code>&gt;</code>가 사실상 다형적(polymorphic)이기 때문에, 심지어 객체를 비롯한
어떠한 타입에도 동작한다. (사실 비트를 가지고 비교하기 때문).</p>
<p>[참고: `max`와 `min`는 라이브러리에 포함되어 있다]</p>
<p>이제 if 문에 대해서 좀더 자세히 알아보자. <code>range</code>는 충분히 설명하지
않았던 함수인데, 아마도 여태까지 배웠던 재귀 함수, 리스트, if 표현식을
조합하면, 이해할 수 있을 것이다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> []
    <span class="keyword">else</span> a :: range (a+1) b</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>이제 이 함수에 몇가지 예제를 적용해 보자. 먼저 쉬운 예로 <code>a &gt; b</code> 부터
해보도록 하자. <code>range 11 10</code> 하면 <code>[]</code> 가 되돌려 진다.(빈 리스트) 그리곤
끝이다.</p>
<p><code>range 10 10</code>를 했을때는 어떨까? <code>10 &gt; 10</code>가 거짓이 되니까 <code>else</code>부분이
계산되어진다, 그렇다면: <code>10 :: (range 11 10)</code> (가독성을 위해 괄호를
넣었다). 방금전에 했던 것처럼 <code>range 11 10</code> = <code>[]</code>다, 따라서 이것은:
<code>10 :: []</code>이다. 앞에서 설명했던 리스트의 <code>::</code> (cons) 연산자가
기억나는가? <code>10 :: []</code>는 <code>[ 10 ]</code> 같다.</p>
<p>이것을 한번 해보자 <code>range 9 10</code>:</p>
<pre><code class="ocaml">range 9 10
&rarr; 9 :: (range 10 10)
&rarr; 9 :: [ 10 ]
&rarr; [9; 10]</code></pre>

<p><code>range 1 10</code> 은 명확하게 다음과 같이 계산되어진다.
<code>[ 1; 2; 3; 4; 5; 6; 7; 8; 9; 10 ]</code>.</p>
<p>여기서 우리가 얻은 것은 단순한 케이스의 재귀호출이다. 미리 이야기
하자면, 함수형 프로그래밍은 루프 보다는 재귀호출을 선호한다고 말할수
있다. 이 장의 마지막 부분에서 재귀호출에 대해 더 논의 할 것이다.</p>
<p>잠시 if 문으로 돌아가면, 아래 함수는 무엇을 하는 것일까?</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">x y </span>=
    x + <span class="keyword">if</span> y &gt; 0 <span class="keyword">then</span> y <span class="keyword">else</span> 0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val f : int -&gt; int -&gt; int = &lt;fun&gt;
</span></code></pre>

<p>단서: 전체 if 표현식에 괄호를 쳐보자. 이 함수는 마치 <a href="https://en.wikipedia.org/wiki/Diode#Current.E2.80.93voltage_characteristic">전기
다이오드</a>처럼
<code>y</code>를 클립(clip)한다.</p>
<p><code>abs</code> (절대값) 함수는 <code>Pervasives</code>에서 다음과 같이 정의된다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">abs</span> <span class="ocaml-variable">x </span>=
    <span class="keyword">if</span> x &gt;= 0 <span class="keyword">then</span> x <span class="keyword">else</span> -x</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val abs : int -&gt; int = &lt;fun&gt;
</span></code></pre>

<p>역시 <code>Pervasives</code>에서 <code>string_of_float</code>함수는 중첩된 if 표현식의 복잡한
쌍을 가지고 있다:</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">string_of_float</span> <span class="ocaml-variable">f </span>=
  <span class="governing">let </span><span class="ocaml-variable">s</span> = format_float <span class="string">&quot;%.12g&quot;</span> f <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">l</span> = string_length s <span class="governing">in</span>
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">i </span>=
    <span class="keyword">if</span> i &gt;= l <span class="keyword">then</span> s ^ <span class="string">&quot;.&quot;</span>
    <span class="keyword">else</span> <span class="keyword">if</span> s.[i] = <span class="string">'.'</span> || s.[i] = <span class="string">'e'</span> <span class="keyword">then</span> s
    <span class="keyword">else</span> loop (i+1) <span class="governing">in</span>
  loop 0</code></pre>

<p>이 함수를 살펴보자. 이 함수를 인자 <code>f</code> = 12.34로 호출 한다면, <code>s</code> =
&quot;12.34&quot;, 그리고 <code>l</code> = 5가 된다. 우리는 <code>loop</code>를 초기값 <code>i</code> = 0로
호출한다.</p>
<p><code>i</code>가 <code>l</code> 보다 크거나 같지 않고 <code>s.[i]</code> (<code>s</code>내에서 <code>i</code>번째 문자)가
마침표 또는 <code>&#39;e&#39;</code>가 아니므로 <code>loop (i+1)</code>가 호출된다, 즉 <code>loop 1</code>.</p>
<p><code>i</code> = 1로 다시 반복하면 <code>loop 2</code>를 호출한다.</p>
<p><code>i</code> = 2의 경우는 <code>s.[i]</code>가 마침표 이므로 (원 문자열을 상기하면 <code>s</code> =
&quot;12.34&quot;), 이는 즉시 <code>s</code>를 반환하고 함수 <code>string_of_float</code>는 &quot;12.34&quot;를
반환한다.</p>
<p><code>loop</code>가 무엇을 하는 것일까? 사실 이 함수는 <code>format_float</code>이 반환한
문자열이 마침표 (또는 <code>&#39;e&#39;</code>)를 포함하고 있는지 검사한다. 만일 <code>12.0</code>로
<code>string_of_float</code>를 호출한다면, <code>format_float</code>는 문자열 &quot;12&quot;를
반환하겠지만, <code>string_of_float</code>는 &quot;12.&quot; 또는 &quot;12.0&quot;를 반환해야 한다
(OCaml의 부동소수점 상수는 정수 상수와 구별하기 위해 마침표를 포함해야
하기 때문에). 그래서 마침표 유무를 검사하는 것이다.</p>
<p>이 함수에서 사용된 이상한 재귀호출은 거의 효율 때문이다. OCaml은 루프를
지원하는데 왜 루프를 사용하지 않았을까? 다음 섹션에서 OCaml의 <code>for</code>
루프가 <code>string_of_float</code> 사용이 불가능 하다는 것을 배울 것이다. 하지만
여기 좀더 직관적이지만 두배 정도 느린 <code>string_of_float</code> 코드가 있다:</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">string_of_float</span> <span class="ocaml-variable">f </span>=
  <span class="governing">let </span><span class="ocaml-variable">s</span> = format_float <span class="string">&quot;%.12g&quot;</span> f <span class="governing">in</span>
  <span class="keyword">if</span> <span class="ocaml-module">String</span>.contains s <span class="string">'.'</span> || <span class="ocaml-module">String</span>.contains s <span class="string">'e'</span>
  <span class="keyword">then</span> s
  <span class="keyword">else</span> s ^ <span class="string">&quot;.&quot;</span></code></pre>

<h2 id="begin-end">begin ... end 사용하기</h2>

<p>lablgtk의 코드 일부를 보자:</p>
<pre><code class="ocaml"><span class="keyword">if</span> <span class="ocaml-module">GtkBase</span>.<span class="ocaml-module">Object</span>.is_a obj cls <span class="keyword">then</span>
  <span class="keyword">fun</span> _ -&gt; f obj
<span class="keyword">else</span> <span class="governing">begin</span>
  eprintf <span class="string">&quot;Glade-warning: %s expects a %s argument.\n&quot;</span> name cls;
  <span class="keyword">raise</span> Not_found
<span class="governing">end</span></code></pre>

<p><code>begin</code>와 <code>end</code>는 열기 및 닫기 괄호에 해당하는 소위 <strong>문법 설탕</strong>이다.
위의 예에서 이들이 하는 것은 <code>else</code> 절 내의 두 개의 문(statement)을
하나로 묶어 주는 것이 전부이다. 대신에 다음과 같이 작성했다고 가정해
보자:</p>
<pre><code class="ocaml"><span class="keyword">if</span> <span class="ocaml-module">GtkBase</span>.<span class="ocaml-module">Object</span>.is_a obj cls <span class="keyword">then</span>
  <span class="keyword">fun</span> _ -&gt; f obj
<span class="keyword">else</span>
  eprintf <span class="string">&quot;Glade-warning: %s expects a %s argument.\n&quot;</span> name cls;
  <span class="keyword">raise</span> Not_found</code></pre>

<p>완전히 괄호를 치고 적절히 인덴트를 한다면 다음과 같이 된다:</p>
<pre><code class="ocaml">(<span class="keyword">if</span> <span class="ocaml-module">GtkBase</span>.<span class="ocaml-module">Object</span>.is_a obj cls <span class="keyword">then</span>
   <span class="keyword">fun</span> _ -&gt; f obj
 <span class="keyword">else</span>
   eprintf <span class="string">&quot;Glade-warning: %s expects a %s argument.\n&quot;</span> name cls
);
<span class="keyword">raise</span> Not_found</code></pre>

<p>의도한 바와 전혀 다르다. 따라서 if 표현식의 <code>then</code> 또는 <code>else</code> 절 내에
있는 여러개의 문(statement)를 묶기 위해서 <code>begin</code>과 <code>end</code>가 필요한
것이다. 또한 원한다면 <code>( ... )</code> 와 같은 일반적인 괄호를 사용할 수도
있다. (나 역시 Pascal을 <strong>질색</strong>하기 때문에 괄호를 더 선호한다 :-).
간단한 예제 두 개를 보자:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="keyword">if</span> 1 = 0 <span class="keyword">then</span>
      print_endline <span class="string">&quot;THEN&quot;</span>
    <span class="keyword">else</span> <span class="governing">begin</span>
      print_endline <span class="string">&quot;ELSE&quot;</span>;
      <span class="keyword">failwith</span> <span class="string">&quot;<span class="keyword">else</span> clause&quot;</span>
    <span class="governing">end</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">ELSE
</span><span class="ocaml-stderr"></span>Exception: Failure &quot;else clause&quot;.
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="keyword">if</span> 1 = 0 <span class="keyword">then</span>
      print_endline <span class="string">&quot;THEN&quot;</span>
    <span class="keyword">else</span> (
      print_endline <span class="string">&quot;ELSE&quot;</span>;
      <span class="keyword">failwith</span> <span class="string">&quot;<span class="keyword">else</span> clause&quot;</span>
    )</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">ELSE
</span><span class="ocaml-stderr"></span>Exception: Failure &quot;else clause&quot;.
</span></code></pre>

<h2 id="for-while">for 루프와 while 루프</h2>

<p>OCaml은 우리에게 익숙한 <code>for</code>를 약간 제한된 형태로 지원한다:</p>
<pre><code class="ocaml"><span class="keyword">for</span> variable = start_value <span class="keyword">to</span> end_value <span class="keyword">do</span>
  expression
<span class="keyword">done</span>
  
<span class="keyword">for</span> variable = start_value <span class="keyword">downto</span> end_value <span class="keyword">do</span>
  expression
<span class="keyword">done</span></code></pre>

<p>lablgtk의 단순하지만 실제 코드를 보면:</p>
<pre><code class="ocaml"><span class="keyword">for</span> i = 1 <span class="keyword">to</span> n_jobs () <span class="keyword">do</span>
  do_next_job ()
<span class="keyword">done</span></code></pre>

<p>OCaml에서 <code>for</code> 루프는 단지 아래의 축약형일 뿐이다:</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">i</span> = 1 <span class="governing">in</span>
do_next_job ();
<span class="governing">let </span><span class="ocaml-variable">i</span> = 2 <span class="governing">in</span>
do_next_job ();
<span class="governing">let </span><span class="ocaml-variable">i</span> = 3 <span class="governing">in</span>
do_next_job ();
  ...
<span class="governing">let </span><span class="ocaml-variable">i</span> = n_jobs () <span class="governing">in</span>
do_next_job ();
()</code></pre>

<p>OCaml은 <code>for</code> 에서 루프의 종료전 빠져나오는 개념을 지원하지 않는다 -
i.e. <code>break</code>, <code>continue</code>, <code>last</code> 문과 같은 것이 없다. (예외를 발생
시키고 외부에서 캐치 하는 방법을 <em>쓸 수도</em> 있는데, 빠르긴 하지만 종종
지저분해 보인다.)</p>
<p>OCaml의 for 루프 내의 표현식은 <code>unit</code> 타입이어야 하며 (그렇지 않으면
컴파일러 경고를 받는다.), 따라서 for 루프 전체의 표현식 역시 <code>unit</code>를
반환한다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="keyword">fo<span class="ocaml-error-loc">r</span></span><span class="ocaml-error-loc"></span> i = 1 <span class="keyword">to</span> 10 <span class="keyword">do</span>
    i <span class="comment">(* &#44221;&#44256;: &#51060; &#54364;&#54788;&#49885;&#51008; unit &#51060;&#45796;. *)</span>
  <span class="keyword">done</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr">Warning 10: this expression should have type unit.
</span>- : unit = ()
</span></code></pre>

<p>함수형 프로그래머들은 명시적인 루프 대신 재귀호출을 사용하는 경향이
있으며, OCaml의 상대적으로 능력이 약한 <strong>for</strong> 루프 때문에 <strong>for</strong>
루프를 의심스럽게 대한다. 아래에서 재귀호출에 대해 이야기 할 예정이다.</p>
<p>OCaml의 <strong>while 루프</strong>는 다음과 같다:</p>
<pre><code class="ocaml"><span class="keyword">while</span> boolean-condition <span class="keyword">do</span>
  expression
<span class="keyword">done</span></code></pre>

<p>for 루프와 같이, 예외를 발생시키지 않고는 while 루프 바깥으로 빠져
나오는 방법은 없다. 이는 while 루프 역시 사용이 제한되어 있다는 점을
의미한다. 다시 말하자면 함수형 프로그래머들은 재귀호출을 좋아 하기
때문에 while 루프는 이 언어에서는 이등 시민으로 간주된다.</p>
<p>만일 while 루프에 한 고려를 중단하면, 이 while 루프가 별다른 쓸모가
없다는 것을 볼 수 있을 것이다, 우리의 오랜 친구 레퍼런스(reference)와
함께 사용하지 않는다면. 잠시 OCaml이 레퍼런스가 없다고 상상해 보자:</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">quit_loop</span> = false <span class="governing">in</span>
<span class="keyword">while</span> not quit_loop <span class="keyword">do</span>
  print_string <span class="string">&quot;Have you had enough yet? (y/n) &quot;</span>;
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_line () <span class="governing">in</span>
  <span class="keyword">if</span> str.[0] = <span class="string">'y'</span> <span class="keyword">then</span>
    <span class="comment">(* how <span class="keyword">do</span> I set quit_loop <span class="keyword">to</span> true ?!? *)</span>
<span class="keyword">done</span></code></pre>

<p><code>quit_loop</code>가 진짜 &quot;변수&quot;가 아니라는 점을 기억하자 - let-바인딩은 단지
<code>quit_loop</code>를 <code>false</code>의 약칭으로 만들어 줄 뿐이다. 이는 while 루프의
조건 (붉은 색의)이 언제나 참이며 루프는 무한히 반복한다는 것이다!</p>
<p>다행스럽게도 OCaml은 레퍼런스가 <em>있어서</em>, 우리는 원하는대로 위 코드를
작성할 수 있다. 느낌표 <code>!</code>가 C/Java에서 처럼 부정을 의미한다고 혼돈하지
말기 바란다. 여기서 의미는 Forth와 비슷하게 &quot;포인터를 디레퍼런스&quot;하는
것을 의미한다. <code>!</code>를 &quot;get&quot; 또는 &quot;deref&quot;라고 읽는 것이 좋다. (역주:
dereference를 역참조로 번역하는 것도 고려했지만, 의미가 잘 통하지 않고
사전에서도 디레퍼런스 - &#39;프로그래밍 언어에서 포인터가 가리키는 번지에
수납된 데이터에 접근하기&#39;로 나와있어 그대로 사용합니다)</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">quit_loop</span> = <span class="keyword">ref</span> false <span class="governing">in</span>
<span class="keyword">while</span> not !quit_loop <span class="keyword">do</span>
  print_string <span class="string">&quot;Have you had enough yet? (y/n) &quot;</span>;
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_line () <span class="governing">in</span>
  <span class="keyword">if</span> str.[0] = <span class="string">'y'</span> <span class="keyword">then</span>
    quit_loop := true
<span class="keyword">done</span></code></pre>

<h2 id="">리스트를 따라 루프 돌기</h2>

<p>리스트를 따라 루프를 돌고 싶다고, 명령형 (imperative) 프로그래머가 되어
믿음직한 총잡이 Mr. For Loop씨를 찾을 필요는 없다. OCaml은 리스트를 따라
루프를 돌 수 있는 더 낫고 빠른 방법을 가지고 있으며, 이들은 모두 <code>List</code>
모듈 내에 들어 있다. 사실 <code>List</code> 모듈 내에는 수십가지의 좋은 함수들이
있지만, 나는 단지 가장 유용한 몇가지만 여기서 이야기 하겠다.</p>
<p>먼저 사용할 리스트를 하나 정의해 보자:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">my_list</span> = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val my_list : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
</span></code></pre>

<p>만일 리스트 내의 모든 요소에 대해 함수를 호출하고 싶다면 <code>List.iter</code>를
다음과 같이 쓰면 된다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">f</span> <span class="ocaml-variable">elem </span>=
    <span class="ocaml-module">Printf</span>.printf <span class="string">&quot;I'm looking at element %d now\n&quot;</span> elem <span class="governing">in</span>
    <span class="ocaml-module">List</span>.iter f my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">I'm looking at element 1 now
I'm looking at element 2 now
I'm looking at element 3 now
I'm looking at element 4 now
I'm looking at element 5 now
I'm looking at element 6 now
I'm looking at element 7 now
I'm looking at element 8 now
I'm looking at element 9 now
I'm looking at element 10 now
</span><span class="ocaml-stderr"></span>- : unit = ()
</span></code></pre>

<p><code>List.iter</code>는 사실 당신의 소뇌가 for 루프 사용을 제안할 때 마다 첫번째로
고려해야할 것이다.</p>
<p>만일 리스트내의 모든 요소를 각각 <em>변화</em>시키고 싶다면 - 예를 들어 각
요소를 두배로 하는 - <code>List.map</code>를 사용하라. 이 함수는 이전에 Perl
프로그래밍을 해 본 사람이라면 친숙할 것이다.</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.map (( * ) 2) my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [2; 4; 6; 8; 10; 12; 14; 16; 18; 20]
</span></code></pre>

<p>펄에는 리스트 내에서 조건을 만족하는 요소들만 골라낼 수 있는 &quot;grep&quot;
이라는 유용한 함수가 있다 - 예를 들어, 리스트 내에서 짝수만 반환하는.
OCaml에서 이 함수는 <code>List.filter</code> 이다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">is_even</span> <span class="ocaml-variable">i </span>=
    i mod 2 = 0 <span class="governing">in</span>
  <span class="ocaml-module">List</span>.filter is_even my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int list = [2; 4; 6; 8; 10]
</span></code></pre>

<p>리스트가 어떤 요소를 가지고 있는지를 확인하기 위해서는 <code>List.mem</code>를
사용하면 된다 (member의 약자):</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.mem 12 my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : bool = false
</span></code></pre>

<p><code>List.for_all</code>와 <code>List.exists</code>는 술어 논리(predicate logic)의 &quot;forall&quot;과
&quot;exist&quot; 연산자와 동일 하다.</p>
<p>두개의 리스트에 대해 동시에 연산을 하고 싶다면, <code>iter2</code>, <code>map2</code>,
<code>for_all2</code>, <code>exists2</code> 등과 같은 접두사 &quot;2&quot;로 끝나는 함수들이 있다.</p>
<p><code>map</code>과 <code>filter</code> 함수는 개별적인 리스트 요소들에 대해 독립적으로
동작한다. <strong>Fold</strong>는 좀 더 일반적이지 않은 동작으로 &quot;리스트의
각 요소들 사이에 연산자를 삽입한다&quot;라고 생각할 수 있다. 리스트 내의 모든
숫자들을 더하고 싶다고 가정해 보자. 대충 이야기 하자면, 내가 원하는 것은
리스트 내의 요소들 사이에 덧셈 기호를 삽입하는 것이다:</p>
<pre><code>1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10</code></pre><p>fold 연산은 이를 해 준다. 비록 정확한 디테일은 약간 더 어렵지만. 맨
먼저, 내가 빈 리스트를 fold 하려 하면 어떤 일이 벌어질까? 이런 경우
에러를 내는 것 보다는 답이 0이면 좋을 것이다. 하지만 내가 리스트의
내적(product)을 구하고자 한다면 다른 답을 원할 것이다. 따라서 fold를
정의하기 위해서는 일종의 &quot;디폴트&quot; 인자를 제공해야 한다. 두 번째 문제는
<code>+</code> 나 <code>*</code>와 같은 단순한 연산자에서는 문제가 발생하지 않는다: 만일
사용하려는 연산자가 결합법칙을 만족하지 않는다면 어떻게 할까, 예를 들어
(a <em>op</em> b) <em>op</em> c 가 a <em>op</em> (b <em>op</em> c)와 다르다면? 이러한 경우 리스트의
왼쪽에서 연산을 시작해 오른쪽으로 가느냐, 오른쪽에서 시작해 왼쪽으로
가느냐가 문제가 된다. 이러한 이유로 fold는 두개의 버전이 존재한다.
<code>List.fold_left</code>는 왼쪽에서 오른쪽으로 가며 <code>List.fold_right</code>는
오른쪽에서 왼쪽으로 오는데 약간 효율이 떨어진다.</p>
<p><code>List.fold_left</code>를 써서 정수 리스트에 대한 <code>sum</code>(합)과 <code>product</code>(곱)
함수를 정의해 보자:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">sum</span> = <span class="ocaml-module">List</span>.fold_left ( + ) 0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val sum : int list -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">product</span> = <span class="ocaml-module">List</span>.fold_left ( * ) 1</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val product : int list -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">sum my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 55
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">product my_list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 3628800
</span></code></pre>

<p>쉽다! 팩토리얼도 같은 방법을 쓸 수 있다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">fact</span> <span class="ocaml-variable">n </span>= product (range 1 n)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val fact : int -&gt; int = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">fact 10</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 3628800
</span></code></pre>

<p>(이 팩토리얼 함수는 정수의 오버플로우 때문에 그다지 크지 않은 <code>n</code> 값에
대해서도 잘못된 값을 반환할 수 있으므로 별로 유용하지는 않다. 실제
팩토리얼 함수는 <code>Big_int</code> 모듈을 사용하여야 한다.)</p>
<h2 id="">문자열을 따라 루프 돌기</h2>

<p><code>String</code> 모듈 역시 수십개의 유용한 문자열 관련 함수들을 가지고 있으며,
이 함수들중 일부는 문자열을 따라 루프를 도는 데 사용된다.</p>
<p><code>String.fill</code>과 <code>String.blit</code>는 C의 <code>memset</code>과 <code>strcpy</code>에 해당한다.
<code>String.copy</code>은 <code>strdup</code>와 같이 문자열을 복사한다.</p>
<p>또한 <code>String.iter</code> 함수가 있어 <code>List.iter</code>와 비슷하게 문자열 내의
문자들에 대해 동작한다.</p>
<h2 id="recursion">재귀 호출 (recursion)</h2>

<p>이제 어려운 주제, 재귀 호출로 넘어 왔다. 함수형 프로그래머들은 이들의
재귀 함수에 대한 사랑으로 정의될 수 있으며, 여러가지로 함수형
프로그래밍에서 재귀 함수는 명령형 프로그래밍에서의 루프와 동일한 것으로
간주된다. 함수형 언어에서 루프는 이등 시민으로 간주되지만, 재귀 함수는
최고의 지원을 받는다.</p>
<p>for 루프와 while 루프를 작성하다 재귀 함수를 작성하는 것은 마인드셋의
변화가 필요하다. 따라서 이 섹션은 소개와 예제를 제공할 것이다.</p>
<p>첫번째 예제에서 우리는 파일 전체를 메모리로(하나의 긴 스트링 형태로)
읽어들일 것이다. 이를 위해서 본질적으로 세가지의 가능한 접근 방법이
있다:</p>
<h3 id="1">방법 1</h3>

<p>파일의 길이를 얻어온 후, <code>really_input</code> 메소드를 사용하여 한번에 모두
읽어 들인다. 가장 쉬운 방법이지만 실제 파일이 아닌 채널(예, 키보드
입력)에서의 경우라면 전체 길이를 미리 알 수 없기 때문에 불가능하고
따라서 다른 접근 방법을 찾아야 한다.</p>
<h3 id="2">방법 2</h3>

<p>명령형 접근으로 예외를 이용한 while 루프를 사용한다.</p>
<h3 id="3">방법 3</h3>

<p>재귀적 루프로 역시 예외를 이용하여 끝을 낸다.</p>
<p>여기서 몇가지 새로운 개념을 소개하겠다. 마지만 두 접근 방법들은 <code>Buffer</code>
모듈 - 확장 가능한 버퍼로 효율적으로 뒤에 텍스트를 덧붙일 수 있는
스트링과 같이 생각할 수 있다. 입력이 종료되면 <code>End_of_file</code> 예외를 캐치
할 수도 있다. 또한 <code>Sys.argv.(1)</code>를 사용하여 커맨드라인 파라미터를 얻을
것이다.</p>
<pre><code class="ocaml"><span class="comment">(* &#51204;&#52404; &#54028;&#51068; &#51069;&#44592;: &#48169;&#48277; 1 *)</span>
<span class="governing">open</span> <span class="ocaml-module">Printf</span>
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_chan</span> <span class="ocaml-variable">chan </span>=
  <span class="governing">let </span><span class="ocaml-variable">len</span> = in_channel_length chan <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">result</span> = <span class="ocaml-module">String</span>.create len <span class="governing">in</span>
  really_input chan result 0 len;
  result
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_file</span> <span class="ocaml-variable">filename </span>=
  <span class="governing">let </span><span class="ocaml-variable">chan</span> = open_in filename <span class="governing">in</span>
  read_whole_chan chan
  
<span class="governing">let</span> () =
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = <span class="ocaml-module">Sys</span>.argv.(1) <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_whole_file filename <span class="governing">in</span>
  printf <span class="string">&quot;I read %d characters from %s\n&quot;</span> (<span class="ocaml-module">String</span>.length str) filename</code></pre>

<p>방법 1은 별로 만족스럽지 않은데 <code>read_whole_chan</code>가 키보드나 소켓과 같은
비-파일 채널에는 동작하지 않기 때문이다. 방법 2는 while 루프를 사용한다:</p>
<pre><code class="ocaml"><span class="comment">(* &#51204;&#52404; &#54028;&#51068; &#51069;&#44592;: &#48169;&#48277; 2 *)</span>
<span class="governing">open</span> <span class="ocaml-module">Printf</span>
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_chan</span> <span class="ocaml-variable">chan </span>=
  <span class="governing">let </span><span class="ocaml-variable">buf</span> = <span class="ocaml-module">Buffer</span>.create 4096 <span class="governing">in</span>
  <span class="keyword">try</span>
    <span class="keyword">while</span> true <span class="keyword">do</span>
      <span class="governing">let </span><span class="ocaml-variable">line</span> = input_line chan <span class="governing">in</span>
      <span class="ocaml-module">Buffer</span>.add_string buf line;
      <span class="ocaml-module">Buffer</span>.add_char buf '\n'
    <span class="keyword">done</span>;
    <span class="keyword">assert</span> false <span class="comment">(* This is never executed
                    (always <span class="keyword">raise</span> Assert_failure). *)</span>
  <span class="keyword">with</span>
    End_of_file -&gt; <span class="ocaml-module">Buffer</span>.contents buf
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_file</span> <span class="ocaml-variable">filename </span>=
  <span class="governing">let </span><span class="ocaml-variable">chan</span> = open_in filename <span class="governing">in</span>
  read_whole_chan chan
  
<span class="governing">let</span> () =
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = <span class="ocaml-module">Sys</span>.argv.(1) <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_whole_file filename <span class="governing">in</span>
  printf <span class="string">&quot;I read %d characters from %s\n&quot;</span> (<span class="ocaml-module">String</span>.length str) filename</code></pre>

<p>방법 2의 핵심은 while 루프의 내부를 보면 된다. while 루프에서 빠져
나오는 유일한 방법은 예외라는 것을 기억하는가? 바로 우리가 하고 있는
것이 그것이다. 비록 예외에 대해 아직 배우지 않았지만, 파일의 끝에
도착했을 때 <code>input_line</code>에 의해 <code>End_of_file</code> 예외가 발생하는 것은 쉽게
이해할 수 있을 것이다. 버퍼 <code>buf</code>는 파일의 내용을 누적시키고, 파일의
끝에 도달했을 때 우리는 이 버퍼를 반환한다 (<code>Buffer.contents buf</code>).</p>
<p>여기서 궁금한 점은 while 루프 직후에 나오는 불필요해 보이는
따옴표(<code>&quot;&quot;</code>)이다. 왜 있는 것일까? while 루프는 for 루프와 마찬가지로
단지 표현식이며, <code>unit</code> 객체(<code>()</code>)를 반환한다. 그러나 OCaml은 <code>try</code> 내의
타입이 각 예외의 반환 타입과 매치 되어야 한다. 이 경우 <code>End_of_file</code>이
<code>string</code>를 반환하기 때문에, <code>try</code>의 본체도 문자열을 &quot;반환&quot;하여야 한다 -
무한 루프를 돌기 때문에 문자열을 반환할 일이 절대 없는 경우에요.</p>
<p>이제 재귀적인 버전의 차례다. 방법 2에 비해 <em>짧다</em>는 것을 주의하기
바란다. 하지만 명령형 프로그래머에게는 이해하기 쉽지 않다:</p>
<pre><code class="ocaml"><span class="comment">(* &#51204;&#52404; &#54028;&#51068; &#51069;&#44592;: &#48169;&#48277; 3 *)</span>
<span class="governing">open</span> <span class="ocaml-module">Printf</span>
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_chan</span> <span class="ocaml-variable">chan </span>=
  <span class="governing">let </span><span class="ocaml-variable">buf</span> = <span class="ocaml-module">Buffer</span>.create 4096 <span class="governing">in</span>
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
    <span class="governing">let </span><span class="ocaml-variable">line</span> = input_line chan <span class="governing">in</span>
    <span class="ocaml-module">Buffer</span>.add_string buf line;
    <span class="ocaml-module">Buffer</span>.add_char buf '\n';
    loop () <span class="governing">in</span>
  <span class="keyword">try</span>
    loop ()
  <span class="keyword">with</span>
    End_of_file -&gt; <span class="ocaml-module">Buffer</span>.contents buf
  
<span class="governing">let</span> <span class="ocaml-function">read_whole_file</span> <span class="ocaml-variable">filename </span>=
  <span class="governing">let </span><span class="ocaml-variable">chan</span> = open_in filename <span class="governing">in</span>
  read_whole_chan chan
  
<span class="governing">let</span> () =
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = <span class="ocaml-module">Sys</span>.argv.(1) <span class="governing">in</span>
  <span class="governing">let </span><span class="ocaml-variable">str</span> = read_whole_file filename <span class="governing">in</span>
  printf <span class="string">&quot;I read %d characters from %s\n&quot;</span> (<span class="ocaml-module">String</span>.length str) filename</code></pre>

<p>역시 무한 루프이지만 이번은 재귀 호출을 이용한다. <code>loop</code>는 함수의
마지막에 자기 자신을 다시 호출한다. 이 무한 재귀 호출은 <code>input_line</code>가
<code>End_of_file</code> 예외를 발생시킬 때 끝이 난다.</p>
<p>방법 3은 매우 큰 파일을 읽을 때 스택 오버플로우를 일으킬 것으로
보이지만, 사실은 그렇지 않다. 아래에서 논의 예정인 꼬리 재귀(tail
recursion) 덕분에 컴파일러는 재귀적인 <code>loop</code> 함수를 실제 while 루프로
바꾸어 정해진 스택 공간내에서 작동할 수 있게 한다.</p>
<p>다음 예에서 우리는 얼마나 재귀 호출이 특히 트리와 같은 특정 타입의 자료
구조를 만드는데 대단한지를 보여줄 것이다. 파일 시스템 내에서 파일을
표현하기 위한 재귀적 타입을 만들어 보자:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">filesystem</span> = File <span class="keyword">of</span> string | Directory <span class="keyword">of</span> filesystem list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type filesystem = File of string | Directory of filesystem list
</span></code></pre>

<p><code>opendir</code>과 <code>readdir</code> 함수가 디렉토리를 열고 디렉토리 내의 요소들을
읽는데 사용될 것이다. 디렉토리의 끝에 다달았을 때 <code>readdir</code>가 내는
성가신 <code>End_of_file</code> 예외를 숨기는 간단한 <code>readdir_no_ex</code> 함수를
정의했다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">open</span> <span class="ocaml-module">Unix</span>  <span class="comment">(*  #load <span class="string">&quot;<span class="ocaml-module">Unix</span>.cma&quot;</span>&#47484; &#54644;&#50556; &#54624; &#49688;&#46020; &#51080;&#45796; *)</span>
    
  <span class="governing">let</span> <span class="ocaml-function">readdir_no_ex</span> <span class="ocaml-variable">dirh </span>=
    <span class="keyword">try</span>
      Some (readdir dirh)
    <span class="keyword">with</span>
      End_of_file -&gt; None</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val readdir_no_ex : Unix.dir_handle -&gt; string option = &lt;fun&gt;
</span></code></pre>

<p><code>readdir_no_ex</code>의 타입은 다음과 같다. Null 포인터에 대한 이전의 논의를
기억해보자.</p>
<pre><code class="ocaml">readdir_no_ex : dir_handle -&gt; string option</code></pre>

<p>나는 또한 <code>filesystem</code> 타입을 (예를 들어) 인쇄가 가능한 문자열로 바꿀 수
있는 간단한 재귀 함수를 정의할 것이다:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">string_of_filesystem</span> <span class="ocaml-variable">fs </span>=
    <span class="keyword">match</span> fs <span class="keyword">with</span>
    | File filename -&gt; filename ^ <span class="string">&quot;\n&quot;</span>
    | Directory fs_list -&gt;
        <span class="ocaml-module">List</span>.fold_left (^) <span class="string">&quot;&quot;</span> (<span class="ocaml-module">List</span>.map string_of_filesystem fs_list)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val string_of_filesystem : filesystem -&gt; string = &lt;fun&gt;
</span></code></pre>

<p><code>fold_left</code>와 <code>map</code> 함수의 사용에 주의하라. <code>map</code>는 리스트 내의 각
<code>filesystem</code>을 <code>string</code>로 (재귀적으로) 바꾸는 데 사용된다.
<code>fold_left (^) &quot;&quot;</code>는 리스트들을 하나의 큰 문자열로 합친다. 또한 패턴
매칭의 사용도 주의하라. (라이브러리에는 <code>fold_left (^) </code>과 본질적으로
동일하며 더 효율적으로 구현된 <code>String.concat</code> 함수가 정의되어 있다).</p>
<p>자 이제 디렉토리 구조를 재귀적으로 읽고, 재귀적인 <code>filesystem</code> 자료
구조를 반환하는 함수를 정의해 보자. 이 함수는 단계적으로 보여줄
것이지만, 전체 함수는 이 섹션의 마지막에 다시 보여줄 것이다. 먼저 함수의
개괄은 다음과 같다:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
  <span class="governing">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="governing">in</span>
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
    <span class="comment">(* ..... *)</span> <span class="governing">in</span>
  Directory (loop ())</code></pre>

<p><code>opendir</code>를 호출하면 주어진 패스를 열고 추후 <code>readdir_no_ex</code>를 이용해
이름들을 읽을 수 있게 해 주는 <code>dir_handle</code>를 반환한다. 반환값은
<code>Directory fs_list</code>이 되며 우리가 해주어야 할 모든 것은 함수 <code>loop</code>를
작성하여 <code>filesystem</code>의 리스트를 반환하게 하는 것이다. <code>loop</code>의 타입은
다음과 같다:</p>
<pre><code class="ocaml">loop : unit -&gt; filesystem list</code></pre>

<p>어떻게 loop를 정의해야 할까? 다시 한 단계 들어가 보자.</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = readdir_no_ex dirh <span class="governing">in</span>
  <span class="comment">(* ..... *)</span></code></pre>

<p>먼저 우리는 디렉토리 핸들(directory handle)에서 다음 파일 이름
(filename)을 읽는다. <code>filename</code>은 <code>string option</code> 타입이며, 다시 말해
<code>None</code>가 되거나 <code>foo</code>가 디렉토리 내의 다음 파일명이라면 <code>Some &quot;foo&quot;</code>가
될 수 있다. 또한 <code>&quot;.&quot;</code> 과 <code>&quot;..&quot;</code> 파일들을 무시해야 한다. (현재
디렉토리와 부모 디렉토리). 이 모든 것을 우리는 패턴 매치를 통해 훌륭히
해 낼 수 있다:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  <span class="governing">let </span><span class="ocaml-variable">filename</span> = readdir_no_ex dirh <span class="governing">in</span>
  <span class="keyword">match</span> filename <span class="keyword">with</span>
  | None -&gt; []
  | Some <span class="string">&quot;.&quot;</span> -&gt; loop ()
  | Some <span class="string">&quot;..&quot;</span> -&gt; loop ()
  | Some filename -&gt;
     <span class="comment">(* ..... *)</span></code></pre>

<p><code>None</code>의 경우는 쉽다. 재귀적으로 생각하면(!) 만일 <code>loop</code>가 호출되고
디렉토리의 끝에 도달했을 때, <code>loop</code>는 엔트리들의 리스트를 반환해야 하고</p>
<ul><li>그런데 엔트리가 없다 - 따라서 빈 리스트를 반환해야 한다 (<code>[]</code>).</li></ul>

<p><code>&quot;.&quot;</code>와 <code>&quot;..&quot;</code>의 경우에는 단순히 무시하고 <code>loop</code>를 다시 호출한다.</p>
<p><code>loop</code>가 실제 파일명(<code>Some filename</code>에서 매치되는)을 읽을 때는 우리는
무엇을 할까? <code>pathname</code>이 파일의 전체 경로라 하자. 이것이 실제
디렉토리인지를 확인하기 위해 파일을 &#39;stat&#39;해 본다. 만일 그것이
디렉토리라면 <code>read_directory</code>를 재귀적으로 호출해 반환되는
<code>Directory something</code>를 <code>this</code>라 하자. <code>read_directory</code>의 최종 결과가
<code>Directory (loop ())</code>라는 것에 주목하자. 만일 파일이 (디렉토리가 아닌)
실제 파일이라면, <code>this</code>가 <code>File pathname</code>라 하자. 자 이제 영리한 짓을 해
보자: <code>this :: loop ()</code>를 반환한다. 이것은 <code>loop ()</code>에 대한 재귀적
호출로 앞에 있는 <code>this</code>에서 남아 있는 디렉토리 멤버들(list)을 계산한다.</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
    <span class="governing">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="governing">in</span>
    <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
      <span class="governing">let </span><span class="ocaml-variable">filename</span> = readdir_no_ex dirh <span class="governing">in</span>
      <span class="keyword">match</span> filename <span class="keyword">with</span>
      | None -&gt; []
      | Some <span class="string">&quot;.&quot;</span> -&gt; loop ()
      | Some <span class="string">&quot;..&quot;</span> -&gt; loop ()
      | Some filename -&gt;
          <span class="governing">let </span><span class="ocaml-variable">pathname</span> = path ^ <span class="string">&quot;/&quot;</span> ^ filename <span class="governing">in</span>
          <span class="governing">let </span><span class="ocaml-variable">stat</span> = lstat pathname <span class="governing">in</span>
          <span class="governing">let </span><span class="ocaml-variable">this</span> = <span class="keyword">if</span> stat.st_kind = S_DIR <span class="keyword">then</span>
                       read_directory pathname
                     <span class="keyword">else</span>
                       File pathname <span class="governing">in</span>
          this :: loop () <span class="governing">in</span>
    Directory (loop ())</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val read_directory : string -&gt; filesystem = &lt;fun&gt;
</span></code></pre>

<p>That&#39;s quite a complex bit of recursion, but although this is a made-up
example, it&#39;s fairly typical of the complex patterns of recursion found
in real-world functional programs. The two important lessons to take
away from this are:</p>
<ul><li><p>The use of recursion to build a list:</p>
<pre class="ocaml"><code class="ocaml"><span class="governing">let</span> <span class="governing">rec</span> <span class="lower">loop</span> <span class="keywordsign">(</span><span class="keywordsign">)</span> <span class="keywordsign">=</span>
  <span class="lower">a</span> <span class="keyword">match</span> <span class="keywordsign">or</span> <span class="keyword">if</span> <span class="lower">statement</span>
  <span class="keywordsign">|</span> <span class="lower">base</span> <span class="lower">case</span> <span class="keywordsign">-&#62;</span> <span class="keywordsign operator">[]</span>
  <span class="keywordsign">|</span> <span class="lower">recursive</span> <span class="lower">case</span> <span class="keywordsign">-&#62;</span> <span class="lower">element</span> <span class="keywordsign">::</span> <span class="lower">loop</span> <span class="keywordsign">(</span><span class="keywordsign">)</span></code></pre>

<p>Compare this to our previous <code>range</code> function. The pattern of recursion
is exactly the same:</p>
<pre class="ocamltop"><code class="ocamltop">let rec range a b =
  if a &gt; b then []            (* Base case *)
  else a :: range (a+1) b     (* Recursive case *)</code></pre></li><li><p>The use of recursion to build up trees:</p>
<pre class="ocaml"><code class="ocaml"><span class="governing">let</span> <span class="governing">rec</span> <span class="lower">read_directory</span> <span class="lower">path</span> <span class="keywordsign">=</span>
  <span class="comment">(* blah blah *)</span>
  <span class="keyword">if</span> <span class="lower">file</span><span class="keywordsign">-</span><span class="lower">is</span><span class="keywordsign">-</span><span class="lower">a</span><span class="keywordsign">-</span><span class="lower">directory</span> <span class="keyword">then</span>
    <span class="lower">read_directory</span> <span class="lower">path</span><span class="keywordsign">-</span><span class="keyword">to</span><span class="keywordsign">-</span><span class="lower">file</span>
  <span class="keyword">else</span>
    <span class="constructor module">Leaf</span> <span class="lower">file</span></code></pre>

<p>All that remains now to make this a working program is a little bit of
code to call <code>read_directory</code> and display the result:</p>
<pre class="ocaml"><code class="ocaml"><span class="governing">let</span> <span class="lower">path</span> <span class="keywordsign">=</span> <span class="constructor module">Sys</span><span class="keywordsign">.</span><span class="lower">argv</span><span class="keywordsign">.</span><span class="keywordsign">(</span><span class="number">1</span><span class="keywordsign">)</span> <span class="governing">in</span>
<span class="governing">let</span> <span class="lower">fs</span> <span class="keywordsign">=</span> <span class="lower">read_directory</span> <span class="lower">path</span> <span class="governing">in</span>
<span class="lower">print_endline</span> <span class="keywordsign">(</span><span class="lower">string_of_filesystem</span> <span class="lower">fs</span><span class="keywordsign">)</span></code></pre></li></ul>

<h3 id="Addendum">Addendum</h3><p>After I posted this example to the caml-list mailing list I received
many follow-ups. (You can <a href="http://caml.inria.fr/pub/ml-archives/caml-list/2003/06/2732fbf1bed1ae50fefb6ea410ea9955.en.html">read the full
thread</a>.)</p>
<p>First of all there is a basic fault with <code>read_directory</code> directory
which will cause it to fail if you try to run it on very large directory
structures. I don&#39;t explicitly call <code>closedir</code> to close the directory
handle. The garbage collector doesn&#39;t help, because in OCaml the garbage
collector does <strong>not</strong> collect and close open file and directory
handles.</p>
<p>The fix is pretty trivial: add a call to <code>closedir</code> at the end of the
<code>read_directory</code> function:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
  <span class="governing">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="governing">in</span>
    <span class="comment">(* ... *)</span>
  <span class="governing">let </span><span class="ocaml-variable">result</span> = Directory (loop ()) <span class="governing">in</span>
  closedir dirh;
  result</code></pre>

<p>Next up is the issue of <code>readdir</code> throwing an exception in a rather
&quot;unexceptional&quot; situation, namely <code>End_of_file</code>. I don&#39;t agree that
throwing an exception in this case is the right thing to do. In typical
programs I want to never have to write a <code>try ... with</code> clause, because
exceptions are supposed to mean &quot;something really bad happened which I&#39;m
not prepared to deal with&quot;, like running out of disk space or memory.
Throwing an exception as part of the routine running of a function
(every program which uses <code>readdir</code> <em>has</em> to be prepared to handle
<code>End_of_file</code>), that&#39;s not an exceptional situation.</p>
<p>However, Eric Cooper came up with a way to write the function and check
the exception, and this highlights another frequent technique used by
functional programmers. Namely, passing an <strong>accumulator</strong> which
contains the result of the function call, but passed as an <em>argument</em> to
the function (!) Really the accumulator means &quot;this is the result so
far&quot;, so in the exceptional case (<code>End_of_file</code>) we give up and return
the result so far. Here is his code with all the references to the
accumulator argument in red:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">read_filesystem</span> <span class="ocaml-variable">path </span>=
    <span class="keyword">if</span> (lstat path).st_kind = S_DIR <span class="keyword">then</span>
      Directory (read_directory path)
    <span class="keyword">else</span>
      File path
    
  <span class="governing"><span class="governing">and</span></span> <span class="ocaml-function">read_directory</span> <span class="ocaml-variable">path </span>=
    <span class="governing">let </span><span class="ocaml-variable">dirh</span> = opendir path <span class="governing">in</span>
    <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">entries </span>=
      <span class="keyword">try</span>
        <span class="keyword">match</span> readdir dirh <span class="keyword">with</span>
        | <span class="string">&quot;.&quot;</span> | <span class="string">&quot;..&quot;</span> -&gt; loop entries
        | filename -&gt;
           loop (read_filesystem (path ^ <span class="string">&quot;/&quot;</span> ^ filename) :: entries)
      <span class="keyword">with</span> End_of_file -&gt; entries <span class="governing">in</span>
    <span class="governing">let </span><span class="ocaml-variable">list</span> = loop [] <span class="governing">in</span>
    closedir dirh;
    list</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val read_filesystem : string -&gt; filesystem = &lt;fun&gt;
val read_directory : string -&gt; filesystem list = &lt;fun&gt;
</span></code></pre>

<p>Notice <code>End_of_file -&gt; entries</code> which means &quot;when we get the exception,
give up and return the result so far&quot;.</p>
<p>Next up - it was pointed out that the easiest way to do this is actually
not to use recursion at all, but instead to do the loop imperatively (a
while loop is probably best) and have a reference to a list to store the
ongoing accumulated result. Because <code>readdir</code> throws an exception, we
have a simple way to break out of the while loop, <em>and</em> in the
<code>with</code>-clause we can just return <code>!list</code> (dereference the reference to
the list of entries we&#39;ve built up).</p>
<p>It all works nicely, and proves that writing code imperatively is often
best, <em>particularly</em> as in this case where
<code>opendir ... readdir ... closedir</code> is essentially an imperative API,
designed for C programmers. It&#39;s no surprise, therefore, that the
imperative solution is easier. OCaml, not being a <a href="http://dictionary.reference.com/browse/bondage-and-discipline+language">bondage and
discipline
language</a>,
doesn&#39;t mind you using the imperative approach when it makes sense.</p>
<p>Here is the outline of the imperative approach by Fabrice Le Fessant:</p>
<pre><code class="ocaml"><span class="governing">let </span><span class="ocaml-variable">list</span> = <span class="keyword">ref</span> [] <span class="governing">in</span>
<span class="governing">let </span><span class="ocaml-variable">dir</span> = opendir <span class="string">&quot;.......&quot;</span> <span class="governing">in</span>
<span class="keyword">try</span>
  <span class="keyword">while</span> true <span class="keyword">do</span>
    <span class="keyword">match</span> readdir dir <span class="keyword">with</span>
    | <span class="string">&quot;.&quot;</span> | <span class="string">&quot;..&quot;</span> -&gt; ()
    | filename -&gt; list := filename :: !list
  <span class="keyword">done</span>;
  <span class="keyword">assert</span> false
<span class="keyword">with</span> End_of_file -&gt; !list</code></pre>

<h3 id="Recursion-example-maximum-element-in-a-list">Recursion example: maximum element in a list</h3><p>Remember the basic recursion pattern for lists:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  a <span class="keyword">match</span> or <span class="keyword">if</span> statement
  | base case -&gt; []
  | recursive case -&gt; element :: loop ()</code></pre>

<p>The key here is actually the use of the match / base case / recursive
case pattern. In this example - finding the maximum element in a list -
we&#39;re going to have two base cases and one recursive case. But before I
jump ahead to the code, let&#39;s just step back and think about the
problem. By thinking about the problem, the solution will appear &quot;as if
by magic&quot; (I promise you :-)</p>
<p>First of all, let&#39;s be clear that the maximum element of a list is just
the biggest one. eg. The maximum element of the list <code>[1; 2; 3; 4; 1]</code>
is <code>4</code>.</p>
<p>Are there any special cases? Yes there are. What&#39;s the maximum element
of the empty list <code>[]</code>? There <em>isn&#39;t one</em>. If we are passed an empty
list, we should throw an error.</p>
<p>What&#39;s the maximum element of a single element list such as <code>[4]</code>?
That&#39;s easy: it&#39;s just the element itself. So <code>list_max [4]</code> should
return <code>4</code>, or in the general case, <code>list_max [x]</code> should return <code>x</code>.</p>
<p>What&#39;s the maximum element of the general list <code>x :: remainder</code> (this is
the &quot;cons&quot; notation for the list, so <code>remainder</code> is the tail - also a
list)?</p>
<p>Think about this for a while. Suppose you know the maximum element of
<code>remainder</code>, which is, say, <code>y</code>. What&#39;s the maximum element of
<code>x :: remainder</code>? It depends on whether <code>x &gt; y</code> or <code>x &lt;= y</code>. If <code>x</code> is
bigger than <code>y</code>, then the overall maximum is <code>x</code>, whereas conversely if
<code>x</code> is less than <code>y</code>, then the overall maximum is <code>y</code>.</p>
<p>Does this really work? Consider <code>[1; 2; 3; 4; 1]</code> again. This is
<code>1 :: [2; 3; 4; 1]</code>. Now the maximum element of the remainder,
<code>[2; 3; 4; 1]</code>, is <code>4</code>. So now we&#39;re interested in <code>x = 1</code> and <code>y = 4</code>.
That head element <code>x = 1</code> doesn&#39;t matter because <code>y = 4</code> is bigger, so
the overall maximum of the whole list is <code>y = 4</code>.</p>
<p>Let&#39;s now code those rules above up, to get a working function:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">list_max</span> <span class="ocaml-variable">xs </span>=
      <span class="keyword">match</span> xs <span class="keyword">with</span>
      | [] -&gt;   <span class="comment">(* empty list: fail *)</span>
         <span class="keyword">failwith</span> <span class="string">&quot;list_max called on empty list&quot;</span>
      | [x] -&gt; <span class="comment">(* single element list: return the element *)</span>
         x
      | x :: remainder -&gt; <span class="comment">(* multiple element list: recursive case *)</span>
         max x (list_max remainder)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val list_max : 'a list -&gt; 'a = &lt;fun&gt;
</span></code></pre>

<p>I&#39;ve added comments so you can see how the rules / special cases we
decided upon above really correspond to lines of code.</p>
<p>Does it work?</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">list_max [1; 2; 3; 4; 1]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 4
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">list_max []</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>Exception: Failure &quot;list_max called on empty list&quot;.
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">list_max [5; 4; 3; 2; 1]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 5
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">list_max [5; 4; 3; 2; 1; 100]</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 100
</span></code></pre>

<p>Notice how the solution proposed is both (a) very different from the
imperative for-loop solution, and (b) much more closely tied to the
problem specification. Functional programmers will tell you that this is
because the functional style is much higher level than the imperative
style, and therefore better and simpler. Whether you believe them is up
to you. It&#39;s certainly true that it&#39;s much simpler to reason logically
about the functional version, which is useful if you wanted to formally
prove that <code>list_max</code> is correct (&quot;correct&quot; being the mathematical way
to say that a program is provably bug-free, useful for space shuttles,
nuclear power plants and higher quality software in general).</p>
<h3 id="Tail-recursion">Tail recursion</h3><p>Let&#39;s look at the <code>range</code> function again for about the twentieth time:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> []
    <span class="keyword">else</span> a :: range (a+1) b</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>I&#39;m going to rewrite it slightly to make something about the structure
of the program clearer (still the same function however):</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> []
    <span class="keyword">else</span>
      <span class="governing">let </span><span class="ocaml-variable">result</span> = range (a+1) b <span class="governing">in</span>
      a :: result</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>Let&#39;s call it:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.length (range 1 10)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 10
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.length (range 1 1000000)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>Stack overflow during evaluation (looping recursion?).
</span></code></pre>

<p>Hmmm ... at first sight this looks like a problem with recursive
programming, and hence with the whole of functional programming! If you
write your code recursively instead of iteratively then you necessarily
run out of stack space on large inputs, right?</p>
<p>In fact, wrong. Compilers can perform a simple optimisation on certain
types of recursive functions to turn them into while loops. These
certain types of recursive functions therefore run in constant stack
space, and with the equivalent efficiency of imperative while loops.
These functions are called <strong>tail-recursive functions</strong>.</p>
<p>In tail-recursive functions, the recursive call happens last of all.
Remember our <code>loop ()</code> functions above? They all had the form:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">loop</span> <span class="ocaml-variable">() </span>=
  <span class="comment">(* <span class="keyword">do</span> something *)</span>
  loop ()</code></pre>

<p>Because the recursive call to <code>loop ()</code> happens as the very last thing,
<code>loop</code> is tail-recursive and the compiler will turn the whole thing into
a while loop.</p>
<p>Unfortunately <code>range</code> is not tail-recursive, and the longer version
above shows why. The recursive call to <code>range</code> doesn&#39;t happen as the
very last thing. In fact the last thing to happen is the <code>::</code> (cons)
operation. As a result, the compiler doesn&#39;t turn the recursion into a
while loop, and the function is not efficient in its use of stack space.</p>
<p>Now recall we discussed in the addendum above Eric Cooper&#39;s
&quot;accumulator&quot; technique, and I said that this technique was widely used
in functional programming. We will now see why this is the case. It&#39;s
because it allows you to write functions such as <code>range</code> above in a
tail-recursive manner, which means they will be efficient and work
properly on large inputs.</p>
<p>Let&#39;s plan our rewritten <code>range</code> function which will use an accumulator
argument to store the &quot;result so far&quot;:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
  <span class="comment">(* ... *)</span>
  
<span class="governing">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
  range2 a b []</code></pre>

<p>(I could and probably should have used a nested function here.)</p>
<p>The <code>accum</code> argument is going to accumulate the result. It&#39;s the &quot;result
so far&quot;. We pass in the empty list (&quot;no result so far&quot;). The easy case
is when <code>a &gt; b</code>:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
  <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> accum
  <span class="keyword">else</span>
    <span class="comment">(* ... *)</span></code></pre>

<p>If <code>a &gt; b</code> (ie. if we&#39;ve reached the end of the recursion), then stop
and return the result (<code>accum</code>).</p>
<p>Now the trick is to write the <code>else</code>-clause and make sure that the call
to <code>range2</code> is the very last thing that we do, so the function is
tail-recursive:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> accum
    <span class="keyword">else</span> range2 (a+1) b (a :: accum)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>There&#39;s only one slight problem with this function: it constructs the
list backwards! However, this is easy to rectify by redefining range as:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>= <span class="ocaml-module">List</span>.rev (range2 a b [])</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>It works this time, although it&#39;s a bit slow to run because it really
does have to construct a list with a million elements in it:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-module">List</span>.length (range 1 1000000)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int = 1000000
</span></code></pre>

<p>The following implementation is twice as fast as the previous one,
because it does not need to reverse a list:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range2</span> <span class="ocaml-variable">a b accum </span>=
    <span class="keyword">if</span> b &lt; a <span class="keyword">then</span> accum
    <span class="keyword">else</span> range2 a (b-1) (b :: accum)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range2 : int -&gt; int -&gt; int list -&gt; int list = &lt;fun&gt;
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    range2 a b []</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p>That was a brief overview of tail recursion, but in real world
situations determining if a function is tail recursive can be quite
hard. What did we really learn here? One thing is that recursive
functions have a dangerous trap for inexperienced programmers. Your
function can appear to work for small inputs (during testing), but fail
catastrophically in the field when exposed to large inputs. This is one
argument <em>against</em> using recursive functions, and for using explicit
while loops when possible.</p>
<h2 id="Mutable-records-references-again-and-arrays">Mutable records, references (again!) and arrays</h2><p>Previously we mentioned records in passing. These are like C <code>struct</code>s:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">pair_of_ints</span> = { a : int; b : int }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type pair_of_ints = { a : int; b : int; }
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">{a=3; b=5}</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : pair_of_ints = {a = 3; b = 5}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-error-loc">{a=3}</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: Some record fields are undefined: b
</span></code></pre>

<p>One feature which I didn&#39;t cover: OCaml records can have mutable fields.
Normally an expression like <code>{a = 3; b = 5}</code> is an immutable, constant
object. However if the record has <strong>mutable fields</strong>, then
there is a way to change those fields in the record. This is an
imperative feature of OCaml, because functional languages don&#39;t normally
allow mutable objects (or references or mutable arrays, which we&#39;ll look
at in a moment).</p>
<p>Here is an object defined with a mutable field. This field is used to
count how many times the object has been accessed. You could imagine
this being used in a caching scheme to decide which objects you&#39;d evict
from memory.</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">name</span> = { name : string; <span class="keyword">mutable</span> access_count : int }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type name = { name : string; mutable access_count : int; }
</span></code></pre>

<p>Here is a function defined on names which prints the <code>name</code> field and
increments the mutable <code>access_count</code> field:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">print_name</span> <span class="ocaml-variable">name </span>=
    print_endline (<span class="string">&quot;The name is &quot;</span> ^ name.name);
    name.access_count &lt;- name.access_count + 1</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val print_name : name -&gt; unit = &lt;fun&gt;
</span></code></pre>

<p>Notice a strange, and very non-functional feature of <code>print_name</code>: it
modifies its <code>access_count</code> parameter. If you read chapter 5 closely,
you&#39;ll see that this function is not &quot;pure&quot;. OCaml is a functional
language, but not to the extent that it forces functional programming
down your throat.</p>
<p>Anyway, let&#39;s see <code>print_name</code> in action:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">n</span> = { name = <span class="string">&quot;Richard Jones&quot;</span>; access_count = 0 }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val n : name = {name = &quot;Richard Jones&quot;; access_count = 0}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : name = {name = &quot;Richard Jones&quot;; access_count = 0}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">print_name n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">The name is Richard Jones
</span><span class="ocaml-stderr"></span>- : unit = ()
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : name = {name = &quot;Richard Jones&quot;; access_count = 1}
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">print_name n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">The name is Richard Jones
</span><span class="ocaml-stderr"></span>- : unit = ()
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">n</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : name = {name = &quot;Richard Jones&quot;; access_count = 2}
</span></code></pre>

<p>Only fields explicitly marked as <code>mutable</code> can be assigned to using the
<code>&lt;-</code> operator. If you try to assign to a non-mutable field, OCaml won&#39;t
let you:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-error-loc">n.name &lt;- </span><span class="string"><span class="ocaml-error-loc">&quot;John Smith&quot;</span></span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: The record field name is not mutable
</span></code></pre>

<p>References, with which we should be familiar by now, are implemented
using records with a mutable <code>contents</code> field. Check out the definition
in <code>Pervasives</code>:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">type</span> <span class="type">'a <span class="keyword">ref</span></span> = { <span class="keyword">mutable</span> contents : 'a }</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>type 'a ref = { mutable contents : 'a; }
</span></code></pre>

<p>And look closely at what the OCaml toplevel prints out for the value of
a reference:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">r</span> = <span class="keyword">ref</span> 100</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val r : int Stdlib.ref = {Stdlib.contents = 100}
</span></code></pre>

<p>Arrays are another sort of mutable structure provided by OCaml. In
OCaml, plain lists are implemented as linked lists, and linked lists are
slow for some types of operation. For example, getting the head of a
list, or iterating over a list to perform some operation on each element
is reasonably fast. However, jumping to the n<sup>th</sup> element of a
list, or trying to randomly access a list - both are slow operations.
The OCaml <code>Array</code> type is a real array, so random access is fast, but
insertion and deletion of elements is slow. <code>Array</code>s are also mutable so
you can randomly change elements too.</p>
<p>The basics of arrays are simple:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">a</span> = <span class="ocaml-module"><span class="ocaml-error-loc">Array</span></span><span class="ocaml-error-loc">.create</span> 10 0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr">Alert deprecated: Stdlib.Array.create
Use Array.make instead.
</span>val a : int array = [|0; 0; 0; 0; 0; 0; 0; 0; 0; 0|]
</span><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="keyword">for</span> i = 0 <span class="keyword">to</span> <span class="ocaml-module">Array</span>.length a - 1 <span class="keyword">do</span>
    a.(i) &lt;- i
  <span class="keyword">done</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : unit = ()
</span><span class="ocaml-prompt"># </span><span class="ocaml-input">a</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>- : int array = [|0; 1; 2; 3; 4; 5; 6; 7; 8; 9|]
</span></code></pre>

<p>Notice the syntax for writing arrays: <code>[| element; element; ... |]</code></p>
<p>The OCaml compiler was designed with heavy numerical processing in mind
(the sort of thing that FORTRAN is traditionally used for), and so it
contains various optimisations specifically for arrays of numbers,
vectors and matrices. Here is some benchmark code for doing dense matrix
multiplication. Notice that it uses for-loops and is generally very
imperative in style:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">size</span> = 30
    
  <span class="governing">let</span> <span class="ocaml-function">mkmatrix</span> <span class="ocaml-variable">rows cols </span>=
    <span class="governing">let </span><span class="ocaml-variable">count</span> = <span class="keyword">ref</span> 1
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">last_col</span> = cols - 1
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m</span> = <span class="ocaml-module">Array</span>.make_matrix rows cols 0 <span class="governing">in</span>
    <span class="keyword">for</span> i = 0 <span class="keyword">to</span> rows - 1 <span class="keyword">do</span>
      <span class="governing">let </span><span class="ocaml-variable">mi</span> = m.(i) <span class="governing">in</span>
      <span class="keyword">for</span> j = 0 <span class="keyword">to</span> last_col <span class="keyword">do</span>
        mi.(j) &lt;- !count;
        incr count
      <span class="keyword">done</span>;
    <span class="keyword">done</span>;
    m
    
  <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">inner_loop</span> <span class="ocaml-variable">k v m1i m2 j </span>=
    <span class="keyword">if</span> k &lt; 0 <span class="keyword">then</span> v
    <span class="keyword">else</span> inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j
    
  <span class="governing">let</span> <span class="ocaml-function">mmult</span> <span class="ocaml-variable">rows cols m1 m2 m3 </span>=
    <span class="governing">let </span><span class="ocaml-variable">last_col</span> = cols - 1
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">last_row</span> = rows - 1 <span class="governing">in</span>
    <span class="keyword">for</span> i = 0 <span class="keyword">to</span> last_row <span class="keyword">do</span>
      <span class="governing">let </span><span class="ocaml-variable">m1i</span> = m1.(i) <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m3i</span> = m3.(i) <span class="governing">in</span>
      <span class="keyword">for</span> j = 0 <span class="keyword">to</span> last_col <span class="keyword">do</span>
        m3i.(j) &lt;- inner_loop last_row 0 m1i m2 j
      <span class="keyword">done</span>;
    <span class="keyword">done</span>
    
  <span class="governing">let</span> () =
    <span class="governing">let </span><span class="ocaml-variable">n</span> =
      <span class="keyword">try</span> int_of_string <span class="ocaml-module">Sys</span>.argv.(1)
      <span class="keyword">with</span> Invalid_argument _ -&gt; 1
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m1</span> = mkmatrix size size
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m2</span> = mkmatrix size size
    <span class="governing"><span class="governing">and</span> </span><span class="ocaml-variable">m3</span> = <span class="ocaml-module">Array</span>.make_matrix size size 0 <span class="governing">in</span>
    <span class="keyword">for</span> i = 1 <span class="keyword">to</span> n - 1 <span class="keyword">do</span>
      mmult size size m1 m2 m3
    <span class="keyword">done</span>;
    mmult size size m1 m2 m3;
    <span class="ocaml-module">Printf</span>.printf <span class="string">&quot;%d %d %d %d\n&quot;</span> m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">270165 1061760 1453695 1856025
</span><span class="ocaml-stderr"></span>val size : int = 30
val mkmatrix : int -&gt; int -&gt; int array array = &lt;fun&gt;
val inner_loop : int -&gt; int -&gt; int array -&gt; int array array -&gt; int -&gt; int =
  &lt;fun&gt;
val mmult :
  int -&gt; int -&gt; int array array -&gt; int array array -&gt; int array array -&gt; unit =
  &lt;fun&gt;
</span></code></pre>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	
<div class="column">
  <div class="entry">
    <h1><a href="../../learn/">Learn</a></h1>
    <ul>
      <li><a href="../../learn/taste.html">Code Examples</a></li>
      <li><a href="../../learn/tutorials/index.ko.html">Tutorials</a></li>
      <li><a href="../../learn/books.html">Books</a></li>
      <li><a href="../../learn/success.html">Success Stories</a></li>
      <li><a href="."></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../docs/">Documentation</a></h1>
    <ul>
      <li><a href="../../docs/install.html">Install</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manual</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Packages</a></li>
      <li><a href="../../releases/index.html">Compiler Releases</a></li>
      <li><a href="../../docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../community/">Community</a></h1>
    <ul>
      <li><a href="../../community/mailing_lists.html">Mailing Lists</a></li>
      <li><a href="../../meetings/">Meetings</a></li>
      <li><a href="../../community/planet/">News</a></li>
      <li><a href="../../community/support.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Bug Tracker</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Website</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/if_statements_loops_and_recursion.ko.md" target="_blank">Edit this page</a></li>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Website Issues</a></li>
      <li><a href="../../about.html">About This Site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Find Us on GitHub</a></li>
      <li><a href="../../contributors.html">Credits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js" type="text/javascript"></script>

     

  </body>
</html>
