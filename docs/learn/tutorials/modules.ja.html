<!DOCTYPE HTML>


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8"/>
    
    <link href="modules.html" rel="alternate" hreflang="en"/>
<link href="modules.fr.html" rel="alternate" hreflang="fr"/>
<link href="modules.ja.html" rel="alternate" hreflang="ja"/>
<link href="modules.ko.html" rel="alternate" hreflang="ko"/>
<link href="modules.zh.html" rel="alternate" hreflang="zh"/>

    
    <title>モジュール &#8211; OCaml</title>
    <link href="../../img/favicon32x32.ico?" rel="shortcut icon" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <link href="//fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css"/>
    
    <link href="../../css/bootstrap.css" rel="stylesheet" media="screen"/>
    <link href="../../css/bootstrap_mod.css" rel="stylesheet" media="screen"/>
    <link href="../../css/ocamlorg.css" rel="stylesheet" media="screen"/>
    
    
    <script src="../../js/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="../../" class="brand"><img src="../../img/colour-logo-white.svg" class="svg" alt="OCaml"/><img src="../../img/colour-logo-white.png" class="png" alt="OCaml"/></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="../../learn/">Learn</a></li>
              <li><a href="../../docs/">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Packages</a></li>
              <li><a href="../../community/">Community</a></li>
              <li><a href="../../community/planet/">News</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/modules.ja.md" title="Edit this page" class="edit-this-page pull-right"><span>Edit this page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input type="hidden" name="as_sitesearch" value="ocaml.org"/>
              <input placeholder="Search" class="search-query" name="q" type="text"/>
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="../../">Home</a><span class="divider"></span></li>
<li><a href="../../learn/">Learn</a><span class="divider"></span></li>
<li><a href="../../learn/tutorials/index.ja.html">OCamlチュートリアル</a><span class="divider"></span></li>
<li class="active">モジュール</li>


    </ol>
    <ul class="translations">
      <li><a href="modules.html">en</a></li>
<li><a href="modules.fr.html">fr</a></li>
<li class="active">日本語</li>
<li><a href="modules.ko.html">한국어</a></li>
<li><a href="modules.zh.html">中文</a></li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contents</a></li>
          <ul><li><a href="#">基本的な使いかた</a>
</li><li><a href="#">インタフェースとシグネチャ</a>
</li><li><a href="#">抽象型</a>
</li><li><a href="#">サブモジュール</a>
<ul><li><a href="#">サブモジュールの実装</a>
</li><li><a href="#">サブモジュールのインタフェース</a>
</li></ul>
</li><li><a href="#">ファンクタ</a>
<ul><li><a href="#">ファンクタとは何か？ なぜ必要なのか？</a>
</li><li><a href="#">既存のファンクタの使いかた</a>
</li><li><a href="#">ファンクタの定義のしかた</a>
</li></ul>
</li><li><a href="#">モジュールの実用的な操作</a>
<ul><li><a href="#">モジュールのインタフェースの表示</a>
</li><li><a href="#">モジュールのインクルード</a>
</li></ul>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        

<h1 id="">モジュール</h1>

<h2 id="">基本的な使いかた</h2>

<p>OCaml では、あらゆるコードがモジュールにくるまれている。
モジュール自身は別のモジュールのサブモジュールになれて、
ファイルシステムのディレクトリにとても良く似ている。
だが、こういうことはあまりしない。</p>
<p>プログラムを書くとき、 <code>amodule.ml</code> と <code>bmodule.ml</code>
というふたつのファイルを使うとすると、 これらのファイルそれぞれ自動的に
<code>Amodule</code>, <code>Bmodule</code> という名前のモジュールと定義し、
ファイルに格納されたものはなんでもそのモジュールで提供する。</p>
<p>ファイル <code>amodule.ml</code> の中に以下のコードがある:</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">&quot;Hello&quot;</span></code></pre>

<p>またファイル <code>bmodule.ml</code> の中に以下のものがある:</p>
<pre><code class="ocaml"><span class="ocaml-module">Amodule</span>.hello ()</code></pre>

<p>普通、ファイルはひとつずつコンパイルされる。そうしてみよう:</p>
<pre class="shell"><code class="shell">ocamlopt -c amodule.ml
ocamlopt -c bmodule.ml
ocamlopt -o hello amodule.cmx bmodule.cmx</code></pre>

<p>これで &quot;Hello&quot; と表示する素晴らしい実行可能ファイルが出来た。
お分かりのように、与えられたモジュールから何かをアクセスしたい場合、
モジュール名(常に大文字で始まる)にピリオドをつけて使いたいもの、
と用いる。
モジュールで提供される物ならば、値、型、コンストラクタ、その他なんでもよい。</p>
<p>標準ライブラリから始まるライブラリ群は、 モジュールの集合体を提供する。
例えば <code>List.iter</code> は <code>List</code> モジュールの <code>iter</code> 関数を指定している。</p>
<p>OK。与えられたモジュールをとことん使いたいなら、
きっと中身に直接アクセスしたいだろう。 それには、<code>open</code>
ディレクティブを使う。 我々の例では、<code>bmodule.ml</code> はこう書くことになる:</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Amodule</span><span class="ocaml-prompt">;;</span><br/>hello ();;</code></pre>

<p>補足すると、みんな醜い&quot;<code>;;</code>&quot;を避ける傾向にあるので、
より一般的にこのように書く:</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Amodule</span>
<span class="governing">let</span> () =
  hello ()</code></pre>

<p>それはともかく、<code>open</code> を使うかどうかは個人の好みの問題だ。
モジュールによっては、
他の多くのモジュールで使われているのと同じ名前を提供する。 例えば <code>List</code>
モジュールがこれにあたる。 普通、<code>open List</code> はしない。 他の <code>Printf</code>
のようなモジュールでは、 <code>printf</code> のように、
普通には衝突してしまわないような名前を提供する。 いたるところで
<code>Printf.printf</code> と書かずに済むように、 ファイルの先頭に <code>open Printf</code>
と書くのが普通の感覚だ。 (訳注:
<a href="guidelines.html">プログラミングのスタイル</a>
も参照せよ)</p>
<p>今言及した事を短い例で示す。</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">open</span> <span class="ocaml-module">Printf</span>
  <span class="governing">let </span><span class="ocaml-variable">my_data</span> = [ <span class="string">&quot;a&quot;</span>; <span class="string">&quot;beautiful&quot;</span>; <span class="string">&quot;day&quot;</span> ]
  <span class="governing">let</span> () = <span class="ocaml-module">List</span>.iter (<span class="keyword">fun</span> s -&gt; printf <span class="string">&quot;%s\n&quot;</span> s) my_data</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout">a
beautiful
day
</span><span class="ocaml-stderr"></span>val my_data : string list = [&quot;a&quot;; &quot;beautiful&quot;; &quot;day&quot;]
</span></code></pre>

<h2 id="">インタフェースとシグネチャ</h2>

<p>モジュールは関数、型、サブモジュール、…といったものを、
それを用いる他のプログラムで使えるように提供する。
特別なことをしなければ、モジュールで定義される全てのものは
外からアクセス可能になる。
小さい個人のプログラムならたいていは良いのだが、
モジュール内部で使う補助関数や補助型は提供せず、
提供する意味のあるものだけをモジュールが供給するほうが良い、
と言う状況はいっぱいある。</p>
<p>そのためにはモジュールインタフェースを定義せねばならない。
それはモジュールの実装をマスクするように機能するだろう。
ちょうどモジュールが <code>.ml</code> ファイルから来ているように、
対応するモジュールインタフェースやシグネチャは <code>.mli</code> ファイルから来る。
ここには型と値のリストなどが含まれる。 <code>amodule.ml</code>
ファイルを書き直そう:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">&quot;Hello&quot;</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val message : string = &quot;Hello&quot;
val hello : unit -&gt; unit = &lt;fun&gt;
</span></code></pre>

<p>これの通りに <code>Amodule</code> には以下のインタフェースがある:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">message</span> : string
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit</code></pre>

<p>他のモジュールが <code>message</code> の値を直接アクセスすることは大きなお世話、
と仮定しよう。 制限されたインタフェースを定義してこれを隠したい。
<code>amodule.mli</code> ファイルはこうだ:</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="comment">(** Displays a greeting message. *)</span></code></pre>

<p>(<a href="../../releases/4.10/htmlman/ocamldoc.html">ocamldoc</a>
がサポートしているフォーマットに基づいて、
<code>.mli</code>ファイルにドキュメントを残すのは良い習慣だ)</p>
<p><code>.mli</code> ファイルは、 マッチする <code>.ml</code>
ファイルの直前にコンパイルされなければならない。 <code>.ml</code> ファイルが
<code>ocamlopt</code> でネイティブコードにコンパイルされる場合であっても、 <code>.mli</code>
は <code>ocamlc</code> でコンパイルされる:</p>
<pre class="shell"><code class="shell">ocamlc -c amodule.mli
ocamlopt -c amodule.ml
...</code></pre>

<h2 id="">抽象型</h2>

<p>型定義はどうだろうか。 関数などの値はその名前や型を <code>.mli</code>
ファイルに書き出すことで、 エクスポートできることを見てきた。たとえば</p>
<pre><code class="ocaml"><span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit</code></pre>

<p>だが、モジュールはしばしば新しい型定義をする。
日付を表す簡単なレコード型を定義しよう:</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span> = { day : int;  month : int;  year : int }</code></pre>

<p><code>.mli</code> ファイルに書き出すときに二つではなく四つの選択肢がある。</p>
<ol><li>型はシグネチャから完全に省略される</li><li>型定義をシグネチャにコピー＆ペーストする</li><li>型を抽象化する: 名前だけを与える</li><li>レコードのフィールドを読みだし専用にする:
 <code>type date = private { ... }</code></li></ol>

<p>3番目の場合では以下のコードになるだろう:</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span></code></pre>

<p>今、モジュールのユーザは型 <code>date</code> のオブジェクトを扱えるが、
レコードのフィールドには直接アクセス出来ない。
モジュールで提供される関数を使わなければならない。 モジュールが 3
つの関数、 日付を生成する関数、 二つの日付の差を計算する関数、
日付を年換算して返す関数、 を提供するとしよう。</p>
<pre><code class="ocaml"><span class="governing">type</span> <span class="type">date</span>
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">create</span> : ?days:int -&gt; ?months:int -&gt; ?years:int -&gt; unit -&gt; date
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">sub</span> : date -&gt; date -&gt; date
<span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">years</span> : date -&gt; float</code></pre>

<p>ポイントは、 <code>create</code> と <code>sub</code> だけが <code>date</code>
レコードを生成するのに用いられるところだ。
したがってモジュールのユーザはおかしな形式のレコードを生成することは出来ない。
実際、この実装ではレコードを使うが、これは変更可能であり、
かつこのモジュールに依存するどのコードも破壊しないことを確信する!
同じライブラリの後発バージョンが内部的にデータ構造を含む実装を変えても、
同じインタフェースを見せ続けているかぎり、 ライブラリは一貫して使える。</p>
<h2 id="">サブモジュール</h2>

<h3 id="">サブモジュールの実装</h3>

<p><code>example.ml</code> ファイルは自動的に <code>Example</code>
という名前のモジュール実装になることを見た。
このモジュールのシグネチャは自動的に派生され可能な限り公開されるか、
もしくは、<code>example.mli</code> ファイルに書くことで制限できる。</p>
<p>つまり、
ファイル内からから明示的に定義されるようなモジュールがありえる。
これは現在のモジュールのサブモジュールを作る。 次の <code>example.ml</code>
ファイルを考えてみよう。</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>= <span class="governing">struct</span>
  <span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">&quot;Hello&quot;</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message
<span class="governing">end</span>
<span class="governing">let</span> <span class="ocaml-function">goodbye</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">&quot;Goodbye&quot;</span>
<span class="governing">let</span> <span class="ocaml-function">hello_goodbye</span> <span class="ocaml-variable">() </span>=
  <span class="ocaml-module">Hello</span>.hello ();
  goodbye ()</code></pre>

<p>別のファイルから見ると、
モジュールがレベルを備えていることが明らかであり、 こう書ける:</p>
<pre><code class="ocaml"><span class="governing">let</span> () =
  <span class="ocaml-module">Example</span>.<span class="ocaml-module">Hello</span>.hello ();
  <span class="ocaml-module">Example</span>.goodbye ()</code></pre>

<h3 id="">サブモジュールのインタフェース</h3>

<p>また、サブモジュールのインタフェースを制限できる。
これはモジュール型と呼ばれる。 <code>example.ml</code> ファイルでやってみよう:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>: <span class="governing">sig</span>
 <span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="governing">end</span> = 
<span class="governing">struct</span>
  <span class="governing">let </span><span class="ocaml-variable">message</span> = <span class="string">&quot;Hello&quot;</span>
  <span class="governing">let</span> <span class="ocaml-function">hello</span> <span class="ocaml-variable">() </span>= print_endline message
<span class="governing">end</span>
  
<span class="comment">(* &#12371;&#12428;&#12391;&#12289;<span class="ocaml-module">Hello</span>.message &#12399;&#12393;&#12371;&#12363;&#12425;&#12418;&#12450;&#12463;&#12475;&#12473;&#12391;&#12365;&#12394;&#12356; *)</span>
<span class="governing">let</span> <span class="ocaml-function">goodbye</span> <span class="ocaml-variable">() </span>= print_endline <span class="string">&quot;Goodbye&quot;</span>
<span class="governing">let</span> <span class="ocaml-function">hello_goodbye</span> <span class="ocaml-variable">() </span>=
  <span class="ocaml-module">Hello</span>.hello ();
  goodbye ()</code></pre>

<p>上記 <code>Hello</code> モジュールの定義は <code>hello.mli</code>/<code>hello.ml</code>
ファイル組と等価である。
コードブロックひとつに全部書くのはエレガントではないので、
普通はモジュールとシグネチャを分割定義するのが好ましい:</p>
<pre><code class="ocaml"><span class="governing">module <span class="governing">type</span></span> <span class="ocaml-module">Hello_type</span> <span class="ocaml-variable"></span>= <span class="governing">sig</span>
 <span class="governing"><span class="governing">val</span></span> <span class="ocaml-function">hello</span> : unit -&gt; unit
<span class="governing">end</span>
  
<span class="governing">module</span> <span class="ocaml-module">Hello</span> <span class="ocaml-variable"></span>: <span class="ocaml-module">Hello_type</span> = <span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p><code>Hello_type</code> は名前つきモジュール型であり、
他のモジュールインタフェース定義に再利用できる。
サブモジュールが役に立つケースはあるだろうが、
この実用性は、ファンクタで明らかになる。 これは次の節で。</p>
<h2 id="">ファンクタ</h2>

<p>ファンクタはおそらく OCaml の中でもっとも複雑な特徴のひとつだが、
OCamlプログラマーとして成功するためにファンクタを広く使いこなす必要はない。
実際、あなた自身ではファンクタを定義したことはないかもしれないが、
標準ライブラリで間違いなく出会うだろう。 ファンクタは Set や Map
モジュールを使う唯一の方法だが、 使うのはそんなに難しくはない。</p>
<h3 id="">ファンクタとは何か？ なぜ必要なのか？</h3>

<p>ファンクタは別のモジュールでパラメータ化されるモジュールであり、
関数が別の値(引数)によってパラメータ化された値であるのと同じようなものだ。</p>
<p>基本的には、OCaml では直接にはできないのだが、
ファンクタは値で型をパラメータ化できる。 例えば、 <code>int n</code>
を引数にとって、 長さ <code>n</code>
の配列だけ排他的に動作するような配列操作を集めたものを返すファンクタを定義できる。
もし間違ってプログラマがこれらの関数のどれかに普通の配列を作用させたら、
コンパイルエラーになるだろう。
もしファンクタではなく標準配列型を使うと、
コンパイラがエラーを検出できないので、
何時か分からない将来にランタイムエラーとなるだろう。
これはとてもひどい話だ。</p>
<h3 id="">既存のファンクタの使いかた</h3>

<p>標準ライブラリでは <code>Set</code> モジュールを定義しており、 これは <code>Make</code>
ファンクタを提供している。 このファンクタは一つの引数をとり、
(少なくとも)二つのもの -- <code>t</code> で与えられる要素の型と <code>compare</code>
で与えられる比較関数 -- を提供するモジュールである。
ファンクタの要点は、 プログラマが間違えたとしても
同じ比較関数がいつも使われることを保証することである。</p>
<p>例えば、<code>int</code> の集合を使いたければこうする:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">Int_set</span> <span class="ocaml-variable"></span>= <span class="ocaml-module">Set</span>.Make (<span class="governing">struct</span>
                               <span class="governing">type</span> <span class="type">t</span> = int
                               <span class="governing">let </span><span class="ocaml-variable">compare</span> = compare
                             <span class="governing">end</span>)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module Int_set :
  sig
    type elt = int
    type t
    val empty : t
    val is_empty : t -&gt; bool
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val singleton : elt -&gt; t
    val remove : elt -&gt; t -&gt; t
    val union : t -&gt; t -&gt; t
    val inter : t -&gt; t -&gt; t
    val disjoint : t -&gt; t -&gt; bool
    val diff : t -&gt; t -&gt; t
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val subset : t -&gt; t -&gt; bool
    val iter : (elt -&gt; unit) -&gt; t -&gt; unit
    val map : (elt -&gt; elt) -&gt; t -&gt; t
    val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a
    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool
    val exists : (elt -&gt; bool) -&gt; t -&gt; bool
    val filter : (elt -&gt; bool) -&gt; t -&gt; t
    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t
    val cardinal : t -&gt; int
    val elements : t -&gt; elt list
    val min_elt : t -&gt; elt
    val min_elt_opt : t -&gt; elt option
    val max_elt : t -&gt; elt
    val max_elt_opt : t -&gt; elt option
    val choose : t -&gt; elt
    val choose_opt : t -&gt; elt option
    val split : elt -&gt; t -&gt; t * bool * t
    val find : elt -&gt; t -&gt; elt
    val find_opt : elt -&gt; t -&gt; elt option
    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val of_list : elt list -&gt; t
    val to_seq_from : elt -&gt; t -&gt; elt Seq.t
    val to_seq : t -&gt; elt Seq.t
    val add_seq : elt Seq.t -&gt; t -&gt; t
    val of_seq : elt Seq.t -&gt; t
  end
</span></code></pre>

<p>文字列の集合では、 標準ライブラリの <code>String</code> モジュールが 型 <code>t</code> と関数
<code>compare</code> を提供しているので、 さらに簡単だ。
ここまで慎重に読んでいれば、
文字列の集合の操作モジュールの生成のしかたを推測できたに違いない:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">String_set</span> <span class="ocaml-variable"></span>= <span class="ocaml-module">Set</span>.Make (String)</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module String_set :
  sig
    type elt = String.t
    type t = Set.Make(String).t
    val empty : t
    val is_empty : t -&gt; bool
    val mem : elt -&gt; t -&gt; bool
    val add : elt -&gt; t -&gt; t
    val singleton : elt -&gt; t
    val remove : elt -&gt; t -&gt; t
    val union : t -&gt; t -&gt; t
    val inter : t -&gt; t -&gt; t
    val disjoint : t -&gt; t -&gt; bool
    val diff : t -&gt; t -&gt; t
    val compare : t -&gt; t -&gt; int
    val equal : t -&gt; t -&gt; bool
    val subset : t -&gt; t -&gt; bool
    val iter : (elt -&gt; unit) -&gt; t -&gt; unit
    val map : (elt -&gt; elt) -&gt; t -&gt; t
    val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a
    val for_all : (elt -&gt; bool) -&gt; t -&gt; bool
    val exists : (elt -&gt; bool) -&gt; t -&gt; bool
    val filter : (elt -&gt; bool) -&gt; t -&gt; t
    val partition : (elt -&gt; bool) -&gt; t -&gt; t * t
    val cardinal : t -&gt; int
    val elements : t -&gt; elt list
    val min_elt : t -&gt; elt
    val min_elt_opt : t -&gt; elt option
    val max_elt : t -&gt; elt
    val max_elt_opt : t -&gt; elt option
    val choose : t -&gt; elt
    val choose_opt : t -&gt; elt option
    val split : elt -&gt; t -&gt; t * bool * t
    val find : elt -&gt; t -&gt; elt
    val find_opt : elt -&gt; t -&gt; elt option
    val find_first : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val find_last : (elt -&gt; bool) -&gt; t -&gt; elt
    val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option
    val of_list : elt list -&gt; t
    val to_seq_from : elt -&gt; t -&gt; elt Seq.t
    val to_seq : t -&gt; elt Seq.t
    val add_seq : elt Seq.t -&gt; t -&gt; t
    val of_seq : elt Seq.t -&gt; t
  end
</span></code></pre>

<p>(括弧が必要)</p>
<h3 id="">ファンクタの定義のしかた</h3>

<p>一つの引数をとるファンクタは次のように定義できる:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>= <span class="governing">struct</span>
 ...
<span class="governing">end</span></code></pre>

<p><code>X</code> はモジュールに引数として渡され、 <code>X_type</code>
はそのシグネチャであり必須だ。</p>
<p>次の構文を使うと、返されるモジュールのシグネチャをつけて強制できる。</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>: <span class="ocaml-module">Y_type</span> =
<span class="governing">struct</span>
  ...
<span class="governing">end</span></code></pre>

<p>あるいは、<code>.mli</code> ファイルで指定できる:</p>
<pre><code class="ocaml"><span class="governing">module</span> <span class="ocaml-module">F</span> <span class="ocaml-variable">(X : X_type) </span>: Y_type</code></pre>

<p>全体的にファンクタの構文は把握しづらい。 標準ライブラリのソースファイル
<code>set.ml</code> や <code>map.ml</code> を見るのがもっとも良いだろう。</p>
<p>最後の注釈: ファンクタは、
正しいプログラムを書くためのプログラマーの手助けとなるものであって、
性能向上のためのものではない。
ファンクタのソースコードにアクセスを必要とするのに、 <code>ocamldefun</code>
のようなデファンクタライザを使わなければ、 実行時のペナルティさえある。</p>
<h2 id="">モジュールの実用的な操作</h2>

<h3 id="">モジュールのインタフェースの表示</h3>

<p><code>ocaml</code> トップレベル環境では、 次のトリックで <code>List</code>
などの既存モジュールの中身を可視化できる。</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">M</span> = <span class="ocaml-module">List</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module M = List
</span></code></pre>

<p>あるいは、ほとんどのライブラリにはオンラインドキュメントがあり、 または
labltk (OCaml の Tk GUI) に付属の <code>ocamlbrowser</code> が使える。</p>
<h3 id="">モジュールのインクルード</h3>

<p>標準の <code>List</code> モジュールに、 とある関数がないのが残念だと思っていて、
モジュールの一部であるかのように使いたいとしよう。 次の <code>extension.ml</code>
ファイルで、 <code>include</code> ディレクティブを用いてこれを達成できる。</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">module</span> <span class="ocaml-module">List</span> <span class="ocaml-variable"></span>= <span class="governing">struct</span>
    <span class="governing">include</span> List
    <span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">optmap</span> <span class="ocaml-variable">f </span>= <span class="keyword">function</span>
      | [] -&gt; []
      | hd :: tl -&gt;
         <span class="keyword">match</span> f hd <span class="keyword">with</span>
         | None -&gt; optmap f tl
         | Some x -&gt; x :: optmap f tl
  <span class="governing">end</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>module List :
  sig
    type 'a t = 'a list = [] | (::) of 'a * 'a list
    val length : 'a list -&gt; int
    val compare_lengths : 'a list -&gt; 'b list -&gt; int
    val compare_length_with : 'a list -&gt; int -&gt; int
    val cons : 'a -&gt; 'a list -&gt; 'a list
    val hd : 'a list -&gt; 'a
    val tl : 'a list -&gt; 'a list
    val nth : 'a list -&gt; int -&gt; 'a
    val nth_opt : 'a list -&gt; int -&gt; 'a option
    val rev : 'a list -&gt; 'a list
    val init : int -&gt; (int -&gt; 'a) -&gt; 'a list
    val append : 'a list -&gt; 'a list -&gt; 'a list
    val rev_append : 'a list -&gt; 'a list -&gt; 'a list
    val concat : 'a list list -&gt; 'a list
    val flatten : 'a list list -&gt; 'a list
    val iter : ('a -&gt; unit) -&gt; 'a list -&gt; unit
    val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a list -&gt; unit
    val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
    val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a list -&gt; 'b list
    val rev_map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list
    val filter_map : ('a -&gt; 'b option) -&gt; 'a list -&gt; 'b list
    val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a
    val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b
    val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit
    val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list
    val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list
    val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'c list -&gt; 'a
    val fold_right2 :
      ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c -&gt; 'c
    val for_all : ('a -&gt; bool) -&gt; 'a list -&gt; bool
    val exists : ('a -&gt; bool) -&gt; 'a list -&gt; bool
    val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool
    val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool
    val mem : 'a -&gt; 'a list -&gt; bool
    val memq : 'a -&gt; 'a list -&gt; bool
    val find : ('a -&gt; bool) -&gt; 'a list -&gt; 'a
    val find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option
    val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
    val find_all : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list
    val partition : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list
    val assoc : 'a -&gt; ('a * 'b) list -&gt; 'b
    val assoc_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option
    val assq : 'a -&gt; ('a * 'b) list -&gt; 'b
    val assq_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option
    val mem_assoc : 'a -&gt; ('a * 'b) list -&gt; bool
    val mem_assq : 'a -&gt; ('a * 'b) list -&gt; bool
    val remove_assoc : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list
    val remove_assq : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list
    val split : ('a * 'b) list -&gt; 'a list * 'b list
    val combine : 'a list -&gt; 'b list -&gt; ('a * 'b) list
    val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list
    val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list -&gt; 'a list
    val to_seq : 'a list -&gt; 'a Seq.t
    val of_seq : 'a Seq.t -&gt; 'a list
    val optmap : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t
  end
</span></code></pre>

<p><code>Extensions.List</code> モジュールを生成しており、 標準の List
モジュールを全部持っているのに加えて 新しい <code>optmap</code> 関数を持っている。
別のファイルからは、 デフォルトの <code>List</code>
モジュールをオーバーライドする必要があるわけだから、 <code>.ml</code>
ファイルの最初に <code>open Extensions</code> と書く。</p>
<pre><code class="ocaml"><span class="governing">open</span> <span class="ocaml-module">Extensions</span>
...
<span class="ocaml-module">List</span>.optmap ...</code></pre>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	
<div class="column">
  <div class="entry">
    <h1><a href="../../learn/">Learn</a></h1>
    <ul>
      <li><a href="../../learn/taste.html">Code Examples</a></li>
      <li><a href="../../learn/tutorials/index.ja.html">Tutorials</a></li>
      <li><a href="../../learn/books.html">Books</a></li>
      <li><a href="../../learn/success.html">Success Stories</a></li>
      <li><a href="."></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../docs/">Documentation</a></h1>
    <ul>
      <li><a href="../../docs/install.html">Install</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manual</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Packages</a></li>
      <li><a href="../../releases/index.html">Compiler Releases</a></li>
      <li><a href="../../docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../community/">Community</a></h1>
    <ul>
      <li><a href="../../community/mailing_lists.html">Mailing Lists</a></li>
      <li><a href="../../meetings/">Meetings</a></li>
      <li><a href="../../community/planet/">News</a></li>
      <li><a href="../../community/support.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Bug Tracker</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Website</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/modules.ja.md" target="_blank">Edit this page</a></li>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Website Issues</a></li>
      <li><a href="../../about.html">About This Site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Find Us on GitHub</a></li>
      <li><a href="../../contributors.html">Credits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js" type="text/javascript"></script>

     

  </body>
</html>
