<!DOCTYPE HTML>


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <meta charset="utf-8"/>
    
    <link href="basics.de.html" rel="alternate" hreflang="de"/>
<link href="basics.el.html" rel="alternate" hreflang="el"/>
<link href="basics.html" rel="alternate" hreflang="en"/>
<link href="basics.fr.html" rel="alternate" hreflang="fr"/>
<link href="basics.it.html" rel="alternate" hreflang="it"/>
<link href="basics.ja.html" rel="alternate" hreflang="ja"/>
<link href="basics.ko.html" rel="alternate" hreflang="ko"/>
<link href="basics.zh.html" rel="alternate" hreflang="zh"/>

    
    <title>はじめの一歩 &#8211; OCaml</title>
    <link href="../../img/favicon32x32.ico?" rel="shortcut icon" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <link href="//fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Domine:400,700" rel="stylesheet"/>
    <link href="//fonts.googleapis.com/css?family=Droid+Sans+Mono" rel="stylesheet" type="text/css"/>
    
    <link href="../../css/bootstrap.css" rel="stylesheet" media="screen"/>
    <link href="../../css/bootstrap_mod.css" rel="stylesheet" media="screen"/>
    <link href="../../css/ocamlorg.css" rel="stylesheet" media="screen"/>
    
    
    <script src="../../js/collapsed-menu.js" type="text/javascript"></script>
    
    
    <script>
      if (document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1')) {
      document.documentElement.className = 'svg';
      }
    </script>
  </head>
  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" onclick="toggleVisibilityMenu('menu-items')">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a href="../../" class="brand"><img src="../../img/colour-logo-white.svg" class="svg" alt="OCaml"/><img src="../../img/colour-logo-white.png" class="png" alt="OCaml"/></a>
          <div id="menu-items" class="nav-collapse collapse">
                        <ul class="nav">
              <li class="active"><a href="../../learn/">Learn</a></li>
              <li><a href="../../docs/">Documentation</a></li>
              <li><a href="https://opam.ocaml.org/">Packages</a></li>
              <li><a href="../../community/">Community</a></li>
              <li><a href="../../community/planet/">News</a></li>
            </ul>

            
            <a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/basics.ja.md" title="Edit this page" class="edit-this-page pull-right"><span>Edit this page</span></a>
	    <script language="JavaScript">
	      // Preload the hover image
	      Image1= new Image(33,33);
	      Image1.src = '/img/edit-hover.svg';
	      Image2= new Image(33,33);
	      Image2.src = '/img/edit-hover.png';
	    </script>
            
            <form id="searchform" class="navbar-search pull-right" method="get" action="//www.google.com/search">
              <input type="hidden" name="as_sitesearch" value="ocaml.org"/>
              <input placeholder="Search" class="search-query" name="q" type="text"/>
            </form>
          </div>
        </div>
      </div>
      
    </nav>
    
    
<div class="container">
  <div class="row">
    
    <div class="span4"></div>
    <div class="span8">
      
<div class="running-header">
  
  <div class="row">
    <ol class="breadcrumb">
      <li><a href="../../">Home</a><span class="divider"></span></li>
<li><a href="../../learn/">Learn</a><span class="divider"></span></li>
<li><a href="../../learn/tutorials/index.ja.html">OCamlチュートリアル</a><span class="divider"></span></li>
<li class="active">はじめの一歩</li>


    </ol>
    <ul class="translations">
      <li><a href="basics.de.html">de</a></li>
<li><a href="basics.el.html">el</a></li>
<li><a href="basics.html">en</a></li>
<li><a href="basics.fr.html">fr</a></li>
<li><a href="basics.it.html">it</a></li>
<li class="active">日本語</li>
<li><a href="basics.ko.html">한국어</a></li>
<li><a href="basics.zh.html">中文</a></li>

    </ul>
  </div>
  
</div>

    </div>
    <div class="span4">
      <nav id="nav-secondary">
        <ul class="nav nav-list">
          <li class="nav-header"><a href="#">Contents</a></li>
          <ul><li><a href="#OCaml">OCamlコードの実行</a>
</li><li><a href="#">コメント</a>
</li><li><a href="#">関数呼び出し</a>
</li><li><a href="#">関数定義</a>
</li><li><a href="#">基本の型</a>
</li><li><a href="#">明示的／暗黙の型変換</a>
<ul><li><a href="#">暗黙と明示的、どちらの型変換がよい？</a>
</li></ul>
</li><li><a href="#">普通の関数と再帰関数</a>
</li><li><a href="#">関数の型</a>
<ul><li><a href="#">多相関数</a>
</li></ul>
</li><li><a href="#">型推論</a>
</li></ul>

        </ul>
      </nav>
    </div>
    <div id="content-primary" class="span8">
            <div id="tryocaml" class="content" style="display:none;">
        <div class="container">
          <div class="row">
            <div id="lesson-message"></div>
            <div id="languages" style="display:none;"></div>
            <div id="menu-lessons" style="display:none">
              <table class="zebra-striped">
                <tr><td id="text-x"><code></code></td> <td></td></tr>
              </table>
            </div>
            <div class="span9 ocaml">
              <div id="toplevel-container">
                <pre id="output"></pre>
                <div id="sharp">#</div>
                <div id="toplevel"></div>
              </div>
              <div id="buttons"></div>
              <div id="graphics-title"></div>
              <div id="graphics"></div>
            </div>
          </div>
        </div>
      </div>

      <div id="main-contents" class="content">
        

<h1 id="">はじめの一歩</h1>

<h2 id="OCaml">OCamlコードの実行</h2>

<p><a href="http://try.ocamlpro.com">TryOCaml</a>のおかげで、ブラウザで対話型セッションを
実行するのが最も簡単な始め方です。</p>
<p>OCamlをコンピューターにインストールするには、<a href="../../docs/install.html">Install</a>
ドキュメントを参照して下さい。</p>
<p>素早く小さいOCamlの式を試すには、対話型のトップレベルまたは、REPL(Read-Eval-Print Loop)
を使うことができます。</p>
<p><code>ocaml</code>コマンドは、基本的なトップレベルを提供します。
(システムのパッケージマネージャーを通して<code>rlwrap</code> をインストールし、
ヒストリーナビゲーションを得るために<code>rlwrap ocaml</code>と実行したほうが良いです。)</p>
<p><code>ocaml</code>コマンドを<a href="../../docs/install.html#OPAM">OPAM</a>または、システムのパッケージマネージャーを通して
インストールした場合は、代わりに<a href="https://github.com/diml/utop">utop</a>トップレベルを使う事をおすすめします。
基本的なインタフェースは同じですが、より便利に使うことができます。(ヒストリーナビゲーション、オートコンプリート等)</p>
<p>各ステートメントが終わったことを示すには、<code>;;</code>を使います。 これは、<code>ocaml</code>実行中の様子です。:</p>
<pre class="console"><code class="console">$ ocaml
        OCaml version 4.10.0

# 1+1;;
- : int = 2</code></pre>

<p>これは、<code>utop</code>を使って同じコードを実行中の様子です。:</p>
<pre class="console"><code class="console">───────┬────────────────────────────────────────────────────────────┬─────
       │ Welcome to utop version 1.18 (using OCaml version 4.02.3)! │     
       └────────────────────────────────────────────────────────────┘     

Type #utop_help for help about using utop.

─( 10:12:16 )─&lt; command 0 &gt;───────────────────────────────────────────────
utop # 1 + 1;;
- : int = 2</code></pre>

<p><code>my_prog.ml</code> という名前のOCamlプログラムをネイティブの実行形式へコンパイルするには、<code>ocamlbuild my_prog.native</code>を使います:</p>
<pre class="shell"><code class="shell">$ mkdir my_project
$ cd my_project
$ echo &#39;let () = print_endline &quot;Hello, World!&quot;&#39; &gt; my_prog.ml
$ ocamlbuild my_prog.native
Finished, 4 targets (0 cached) in 00:00:00.
$ ./my_prog.native
Hello, World!</code></pre>

<p>詳細に付いては、<a href="compiling_ocaml_projects.html">Compiling OCaml projects</a>を参照して下さい。</p>
<h2 id="">コメント</h2>

<p>OCamlのコメントは<code>(*</code> と <code>*)</code>で囲まれた部分である。</p>
<pre><code class="ocaml"><span class="comment">(* &#12371;&#12428;&#12399;&#19968;&#34892;&#12384;&#12369;&#12398;&#12467;&#12513;&#12531;&#12488; *)</span>

<span class="comment">(* &#12371;&#12428;&#12399;
 * &#35079;&#25968;&#34892;&#12395;&#28193;&#12427;
 * &#12467;&#12513;&#12531;&#12488;
 *)</span></code></pre>

<p>別の言い方をすると、コメントの仕方はCに昔からあるコメント文によく似ている。(<code>/* ... */</code>)
また (Perl の <code>#...</code> や C99, C++, Java の <code>//...</code> のような)
行コメントの文法はない。</p>
<p>Ocaml では <code>(* ... *)</code> のネスト(入れ子)が許されており、
コードのある範囲をまとめてコメントアウトすることも簡単にできる。</p>
<pre><code class="ocaml"><span class="comment">(* &#12371;&#12398;&#12467;&#12540;&#12489;&#12399;&#20316;&#12426;&#12363;&#12369;&hellip;

(* &#32032;&#25968;&#12486;&#12473;&#12488; *)
<span class="governing">let</span> <span class="ocaml-function">is_prime</span> <span class="ocaml-variable">n </span>=
  (* &#33258;&#20998;&#12408;&#12398;&#12513;&#12514;: &#12371;&#12428;&#12434;&#12513;&#12540;&#12522;&#12531;&#12464;&#12522;&#12473;&#12488;&#12391;&#32862;&#12367;&#12371;&#12392; *)XXX<span class="ocaml-prompt">;;</span><br/>*)</span></code></pre>

<h2 id="">関数呼び出し</h2>

<p>さて、何か関数を定義したとしよう。例えば<code>repeated</code>という関数を定義したとする。これは文字列<code>s</code>と整数<code>n</code>を引数にとり、<code>s</code>を<code>n</code>回繰り返した新しい文字列を返す関数とする。</p>
<p>Cに由来するほとんどの言語では、この関数を呼び出すときにはこのようにする。</p>
<pre class="C"><code class="C">repeated (&quot;hello&quot;, 3)  /* Cコード*/</code></pre><p>これは、「関数<code>repeated</code>を2つの引数により呼び出す。最初の引数は文字列helloであり、二番目の引数は3である」ことを意味する。</p>
<p>ところが、OCamlやその他の関数型言語では関数呼び出しを違ったように書く。特に括弧のつけ方が異なり、間違いの元になりやすい。上と同じ関数呼び出しをOCamlで書くと、</p>
<pre><code class="ocaml">repeated <span class="string">&quot;hello&quot;</span> 3  <span class="comment">(* OCaml&#12467;&#12540;&#12489; *)</span></code></pre>

<p><strong>括弧がないこと</strong>、<strong>引数の間のコンマがないこと</strong>に注意しよう。</p>
<p>ややこしいことに、<code>repeated (&quot;hello&quot;, 3)</code>はOCamlでちゃんとした<strong>意味がある</strong>。これは「関数<code>repeated</code>を<strong>一つ</strong>の引数で呼び出す。引数は文字列helloと整数3の組である。」を意味する。もちろんこれは誤りである。<code>repeated</code>は2つの引数を取り、しかも最初の引数は文字列であって組ではないからだ。しかしとりあえず組(tuple)については考えないことにしよう。まず引数のまわりを括弧でくくらないこと、引数をコンマで分けないことを覚えよう。</p>
<p>さて次に別の関数を考えよう。<code>get_string_from_user</code>はユーザーから文字列の入力を受け、入力された文字列を返す関数である。この関数の戻り値を<code>repeated</code>に渡したい。CとOCamlのコードを比較しよう。</p>
<pre class="C"><code class="C">/* Cコード: */
repeated (get_string_from_user (&quot;Please type in a string.&quot;), 3)</code></pre>
<pre><code class="ocaml"><span class="comment">(* OCaml&#12467;&#12540;&#12489;: *)</span>
repeated (get_string_from_user <span class="string">&quot;Please <span class="governing">type</span> <span class="governing">in</span> a string.&quot;</span>) 3</code></pre>

<p>括弧のつけ方とコンマの有無に注意してほしい。一個で言うと「関数呼び出し全体を括弧でくくる。引数の周りには括弧はつけない。」ということになる。さらに例を示そう。</p>
<pre><code class="ocaml">f 5 (g <span class="string">&quot;hello&quot;</span>) 3    <span class="comment">(* f&#12398;&#24341;&#25968;&#12399;3&#12388;&#12290;g&#12399;&#19968;&#12388; *)</span>
f (g 3 4)            <span class="comment">(* f&#12398;&#24341;&#25968;&#12399;&#19968;&#12388;&#12290;g&#12399;2&#12388;&#12290;*)</span></code></pre>

<div style="display: none">

<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">repeated</span> <span class="ocaml-variable">(s: string) (i: int) </span>=
    <span class="keyword">failwith</span> <span class="string">&quot;implementation not given&quot;</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val repeated : string -&gt; int -&gt; 'a = &lt;fun&gt;
</span></code></pre></div>

<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">repeated <span class="ocaml-error-loc">(</span><span class="string"><span class="ocaml-error-loc">&quot;hello&quot;</span></span><span class="ocaml-error-loc">, 3)</span>     <span class="comment">(* &#12456;&#12521;&#12540;&#12395;&#12394;&#12427;&#12290; *)</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: This expression has type 'a * 'b
       but an expression was expected of type string
</span></code></pre>

<h2 id="">関数定義</h2>

<p>既存の言語で関数(Java を嗜んでいるのなら静的メソッド)
を定義する方法はご存じでしょう。 では、OCaml ではどうするのでしょうか？</p>
<p>OCaml の文法は晴れ晴れするほどすっきりしています。
二つの浮動小数点数を引数にとって平均を計算する関数があります：</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">average</span> <span class="ocaml-variable">a b </span>=
  (a +. b) /. 2.0;;</code></pre>

<p>OCaml の&quot;トップレベル&quot; (Unix なら <code>ocaml</code>
コマンドをシェルプロンプトから入力してください)
にこれを入力すると、こうなります：</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">average</span> <span class="ocaml-variable">a b </span>=
    (a +. b) /. 2.0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val average : float -&gt; float -&gt; float = &lt;fun&gt;
</span></code></pre>

<p>この関数定義を良く見て、また OCaml がどういう応答を返したのかを
見るといろいろと疑問に思う点が出てくるでしょう。</p>
<ul><li>このコードの演算子の後ろについている <code>.</code> は何？</li><li><code>float -&gt; float -&gt; float</code> とかいうの、これ何？</li></ul>

<p>次節でこれらの疑問に答えていきますが、その前にまず、
この関数と同じものを C で定義します (Java も C と似たようなものです)。
するともっと疑問が浮かぶかも知れません。 C バージョンの <code>average</code>:</p>
<pre class="C"><code class="C">double average (double a, double b)
{
  return (a + b) / 2;
}</code></pre><p>先に示した OCaml 版のとても短い関数定義と見比べましょう。
こんな疑問が浮かびませんか？:</p>
<ul><li>OCaml 版で <code>a</code>や<code>b</code> の型宣言をしなくていいの？OCaml
 はどうやって型を知るのですか？(OCaml
 は本当にその型を知っているのですか？完全に動的型なのですか？)</li><li>C では <code>2</code> は暗黙の型変換で <code>double</code> に変換されますが、OCaml
 ではどうしてそうならないのですか？</li><li><code>return</code> を OCaml ではどう書くのですか？</li></ul>

<p>じゃぁ答えていきましょう。</p>
<ul><li>OCaml は強い静的型付けされた言語です。(言い換えると、Perl
 のような動的型ではありません)</li><li>OCaml
 は<em>型推論</em>によって型を抽出するので、明示する必要はありません。先の通り
 OCaml の トップレベルで用いれば、OCaml は入力した関数の型を(OCaml
 がどう推論したのかを)教えてくれます。</li><li>OCaml
 には暗黙の型変換はありません。もし浮動小数点数を使うのであれば、<code>2</code>
 は整数型なので <code>2.0</code> と書く必要があります。</li><li>OCaml
 には演算子の多重定義は禁止されているので、「整数の足し算(<code>+</code>)」
 と「浮動小数点数の足し算(<code>+. </code>)」(付随するピリオドに注意)とで異なる演算子が用意されています。他の算術演算子も同様です。</li><li>OCaml は関数の最後の式を返値とするので、C のように<code>return</code>
 を書く必要はありません。</li></ul>

<p>詳細は次の節、章に示します。</p>
<h2 id="">基本の型</h2>

<p>OCaml の基本型は以下の通りです。</p>
<pre class="text"><code class="text">OCaml の型       範囲

int            32ビットCPU では 31ビット符号付き整数 (およそ±10億)、64ビットCPU では 63ビット符号付き整数
float          IEEE 倍精度浮動小数点数、C の double と同じ
bool           true もしくは false となる真偽値
char           8bit 文字
string         文字列
unit           () と書くもの</code></pre>

<p>OCaml では整数型(<code>int</code>)の 1ビットを
自動的なメモリ管理(ガベージコレクション)のために内部的に使っているため、
<code>int</code> 型が 32ビットでなく 31 ビット(64ビット環境なら
63ビット)となっています。
この違いはごく特定のケースの除いて問題にはならないでしょう。
たとえばループの回数を数える場合、OCaml では 20 億ではなく10億までしか
カウントできないことになりますが、
どんな言語でもこの限界近くでカウントするのなら、巨大数を扱える型 (OCaml
なら <code>Nat</code> や <code>Big_int</code> モジュール)を使うべきであるので、
この制限が問題になることはないでしょう。 とはいえ、32bit
整数型を使いたいとき
(例:暗号コードやネットワークスタックなどを書くとき)には、 OCaml
にはあなたの環境の普通の整数型に相当する <code>nativeint</code> 型があります。</p>
<p>OCaml には符号なし整数型は基本型としてはありませんが、 <code>nativeint</code>
型を使えば同じことができます。 あと、OCaml
には単精度の浮動小数点数は存在しません。</p>
<p>OCaml には文字型として <code>char</code>型があり、 <code>&#39;x&#39;</code> などと書きます。
残念ながら <code>char</code>型では Unicode、UTF-8 はサポートしていません。 これは
OCaml で対応してしかるべき重大な欠陥ですが、 かわりに <a href="http://camomile.sourceforge.net/" title="http://camomile.sourceforge.net/">comprehensive
Unicode
libraries</a>
があります。</p>
<p><code>string</code> 型は単なる文字のリストと言うわけではありません。
もっと効率的な内部表現で実装されています。</p>
<p><code>unit</code> 型は C の <code>void</code> 型に似ていますが、
これについてはもう少し後で述べます。</p>
<h2 id="">明示的／暗黙の型変換</h2>

<p>C やその派生言語では、整数型がある特定の条件で浮動小数点型に昇格します。
たとえば、<code>1 + 2.5</code> と書いた場合、
第一引数の整数は浮動小数点数に昇格して、結果は浮動小数点数になります。
<code>((double) 1) + 2.5</code> と書いたのと同じ実行結果になるわけですが、
これが暗黙の内に行われます。</p>
<p>OCaml ではこのような暗黙の型変換は一切行われません。 OCaml で <code>1 + 2.5</code>
と書くと型エラーとなります。 OCaml の <code>+</code>
演算子は二つの整数を引数に取るので、ここで
整数と浮動小数点数を与えられるとエラーを通知します。</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input">1 + <span class="ocaml-error-loc">2.5</span></span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: This expression has type float but an expression was expected of type
         int
</span></code></pre>

<p>(OCaml のエラーメッセージはフランス語から英訳されたもので、 「float
になっているけど int を使うべきでは？」
「あなたは浮動小数点数を使ったがここは整数型が期待されている」
くらいの意味です。訳注：日本語を母語とする我々にはどうでもいい話ですね)</p>
<p>二つの浮動小数点数を足し算したい場合にはこれと違う演算子 <code>+.</code> を
使います (後置されているピリオドに注意)。</p>
<p>OCaml は自動的に int を float
に昇格することはないので、次のも間違いです:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="ocaml-error-loc">1</span> +. 2.5</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-error">Error: This expression has type int but an expression was expected of type
         float
</span></code></pre>

<p>OCaml は第一引数に文句をつけています。</p>
<p>もし本当に整数と浮動小数点を足し算したい場合、どうすれば良いでしょうか
(それぞれ <code>i</code> と <code>f</code> という変数に格納されているとします)。 OCaml
では明示的なキャストが必要です。</p>
<pre><code class="ocaml">(float_of_int i) +. f</code></pre>

<p><code>float_of_int</code> は <code>int</code> をとって <code>float</code> を返す関数です。 これらの関数は
<code>int_of_float</code>, <code>char_of_int</code>, <code>int_of_char</code>, <code>string_of_int</code> など
全組合わせあり、概ね想像通りの動作をするはずです。</p>
<p><code>int</code> から <code>float</code> への変換が特に良く出てくるので、 <code>float_of_int</code>
関数には短い別名が付けられており、 上の例はこのようになります。</p>
<pre><code class="ocaml">float i +. f</code></pre>

<p>(C と違い OCaml では型と関数が全く同じ名前です)</p>
<h3 id="">暗黙と明示的、どちらの型変換がよい？</h3>

<p>これらの明示的なキャストが見苦しくて手間もかかると思うかも知れません。
確かに一理あるのですが、
明示的キャストを支持する少なくとも以下の議論があります。
一つめは、明示的な型変換を必須とすることによって、OCaml では型推論(後述)
が実現できています。
型推論は明示的なキャストによる余分なタイピングを相殺して余りあるだけの
すばらしい時間節約効果があります。 二つめは、C
でデバッグの手間がかかっているのなら、 (a)
暗黙のキャストに起因するバグが探しづらいこと、 (b)
暗黙のキャストが何処でどう実行されたのか試行錯誤するのに時間がかかること、
に気づくべきです。 キャストを明示することでデバッグが楽になります。
三つめに、ある種のキャスト(特に int &lt;-&gt; float)
は高価な変換操作である事実です。
型変換を明示しないことによる利益はないと思いますよ。</p>
<h2 id="">普通の関数と再帰関数</h2>

<p>C などの言語と違って、 単に <code>let</code> ではなく <code>let rec</code>
と明示的に書かない限り、 関数は再帰的には使えません。
再帰関数の例を示します:</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing"><span class="governing">let rec</span></span> <span class="ocaml-function">range</span> <span class="ocaml-variable">a b </span>=
    <span class="keyword">if</span> a &gt; b <span class="keyword">then</span> []
    <span class="keyword">else</span> a :: range (a+1) b</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val range : int -&gt; int -&gt; int list = &lt;fun&gt;
</span></code></pre>

<p><code>range</code> 関数が自分自身を呼び出していますね。</p>
<p><code>let</code> と <code>let rec</code> の違いは関数名のスコープだけです。 この関数 <code>range</code>
が単に <code>let</code> で定義された場合には、 <code>range</code>
の呼び出しのところで、今定義しているところの <code>range</code> 関数
ではなく、既に存在するはずの(既に定義された) <code>range</code> 関数を探します。</p>
<p><code>let</code> と <code>let rec</code> で定義された関数で性能的な違いはありません。
なので、常に <code>let rec</code> を使うことにすれば C
のようなセマンティックになります。</p>
<h2 id="">関数の型</h2>

<p>型推論があるので、関数の型を明示して書き下す必要はほとんどありません。
しかし、あなたの書いた関数を OCaml がどう推論したのかが表示されるので、
この文法を知っておく必要はあるでしょう。 関数 <code>f</code> が引数 <code>arg1</code>, <code>arg2</code>,
..., <code>argn</code>を取り、 <code>rettype</code> 型を返すとき、OCaml
コンパイラはこう表示します:</p>
<pre><code class="ocaml">f : arg1 -&gt; arg2 -&gt; ... -&gt; argn -&gt; rettype</code></pre>

<p>矢印は変に見えるかも知れません。が、
後述する「カリー化」というものを知ると何故こう表示されるのかも納得が行くでしょう。
今はとりあえずいくつかの例を示します。</p>
<p>関数 <code>repeated</code>
は文字列と数値を引数にとって文字列を返すのでした。この型は</p>
<pre><code class="ocaml">repeated : string -&gt; int -&gt; string</code></pre>

<p>関数 <code>average</code>
は浮動小数点数を二つ引数にとって浮動小数点数を返すのでした。</p>
<pre><code class="ocaml">average : float -&gt; float -&gt; float</code></pre>

<p>OCaml 標準のキャスト関数の <code>int_of_char</code> は:</p>
<pre><code class="ocaml">int_of_char : char -&gt; int</code></pre>

<p>もし関数が何も返さない (C や Java の <code>void</code>) のなら、 <code>unit</code>
型を返す、と書きます。 たとえば <code>fputc</code> と同等の OCaml 関数は:</p>
<pre><code class="ocaml">output_char : out_channel -&gt; char -&gt; unit</code></pre>

<h3 id="">多相関数</h3>

<p>ここでちょっと変わったものを紹介します。
引数が<em>何でも良い</em>ような関数というのはどうでしょう。</p>
<p>ここで引数を取るけれどそれを無視して常に3を返す変な関数があります。</p>
<pre><code class="ocaml"><span class="governing">let</span> <span class="ocaml-function">give_me_a_three</span> <span class="ocaml-variable">x </span>= 3</code></pre>

<p>この関数の型はなんでしょう？ OCaml
では「使いたいどんな型でも」という意味の特別な記法があります。
単引用符(アポストロフィ)に文字、です。
普通、上の関数の型はこう表記されます。</p>
<pre><code class="ocaml">give_me_a_three : 'a -&gt; int</code></pre>

<p>ここで <code>&#39;a</code> はどんな型でも良いことを意味します。 たとえばこの関数を
<code>give_me_a_three &quot;foo&quot; </code> とか <code>give_me_a_three 2.0</code> とか呼び出しても、
いずれも OCaml として正しい式です。</p>
<p>しかしこの例では多相関数が何故有用なのかは分からないでしょう。
一般的にはとても有用なのですが、それはおいおい述べようと思います。
(ヒント: 多相関数は C++ や Java 1.5 等のテンプレートに似ています)</p>
<h2 id="">型推論</h2>

<p>このチュートリアルのテーマは、
関数型言語には本当にすごい特徴がいっぱいあって、 OCaml
はそれらを余すところなく詰め込んだ言語になっていること、
そして、そうだからこそ、
本物のプログラマが実戦で使っている言語になっていること、です。
しかし、これら本当にすごい特徴というものの多くは、
実は「関数型プログラミング」とは関係がなかったりします。
実際、これから最初の本当に凄い特徴を述べますが。
まだ関数型プログラミングが何故「関数型」と呼ばれるのか、
ここでもまだ言及しません。
ともかく、これが最初の本当に凄い特徴です。型推論。</p>
<p>一言で言うと、
あなたが書いた関数や変数の型を明示的に宣言する必要がなく、 OCaml
があなたのかわりにやってくれるものです。</p>
<p>さらに OCaml は型の整合が取れているかどうかを
(別のファイルにあるものでも) チェックしてくれます。</p>
<p>しかし、OCaml は実用的な言語でもあるので、
型チェックをバイパスするような型システムの抜け道を用意してあります。
よほどのハッカーでもない限りこんな抜け道を使うことはないでしょうが。</p>
<p>さて前に出てきた <code>average</code> 関数に戻りましょう。</p>
<pre><code class="ocamltop"><span class="ocaml-prompt"># </span><span class="ocaml-input"><span class="governing">let</span> <span class="ocaml-function">average</span> <span class="ocaml-variable">a b </span>=
    (a +. b) /. 2.0</span><span class="ocaml-prompt">;;</span><br/><span class="ocaml-output"><span class="ocaml-stdout"></span><span class="ocaml-stderr"></span>val average : float -&gt; float -&gt; float = &lt;fun&gt;
</span></code></pre>

<p>摩訶不思議！ OCaml は勝手にこの関数が二つの <code>float</code> を引数にとって
<code>float</code> を返すと判断しました。</p>
<p>どうしてこんなことができるのでしょう？ まず、<code>a</code> と <code>b</code>
が何処で使われてるのか、つまり <code>(a +. b)</code> を見てみます。 <code>+.</code>
というのは常に二つの <code>float</code> を引数にとる単純な関数なので、 <code>a</code> も <code>b</code>
も <code>float</code> でないといけません。</p>
<p>次に、<code>/.</code> も <code>float</code> を返す関数で、 これが <code>average</code>
関数の返値になるわけですから、 <code>average</code> 関数の返値の型もまた同じく
<code>float</code> でないといけません。 したがって、まとめると <code>average</code> の型は</p>
<pre><code class="ocaml">average : float -&gt; float -&gt; float</code></pre>

<p>型推論はこれくらい短いプログラムだととても簡単ですが、
大きなプログラムであってもちゃんと動きます。 型推論は、
他の言語で良くありがちなセグメントフォールトや <code>NullPointerExceptions</code>,
<code>ClassCastExceptions</code> (Perl だとせっかく実行時警告が出るのに無視したり…)
などを引き起こすようなバグを取り除くことになるので、
これこそが最も時間の節約になる特徴となっています。</p>

      </div>
    </div>
    
    
  </div>
</div>

    
    <footer id="footer" class="navbar navbar-inverse">
      <div class="navbar-inner">
	
<div class="column">
  <div class="entry">
    <h1><a href="../../learn/">Learn</a></h1>
    <ul>
      <li><a href="../../learn/taste.html">Code Examples</a></li>
      <li><a href="../../learn/tutorials/index.ja.html">Tutorials</a></li>
      <li><a href="../../learn/books.html">Books</a></li>
      <li><a href="../../learn/success.html">Success Stories</a></li>
      <li><a href="."></a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../docs/">Documentation</a></h1>
    <ul>
      <li><a href="../../docs/install.html">Install</a></li>
      <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/">Manual</a></li>
      <li><a href="https://opam.ocaml.org/packages/">Packages</a></li>
      <li><a href="../../releases/index.html">Compiler Releases</a></li>
      <li><a href="../../docs/logos.html">Logos</a></li>
    </ul>
  </div>
</div>
<div class="column">
  <div class="entry">
    <h1><a href="../../community/">Community</a></h1>
    <ul>
      <li><a href="../../community/mailing_lists.html">Mailing Lists</a></li>
      <li><a href="../../meetings/">Meetings</a></li>
      <li><a href="../../community/planet/">News</a></li>
      <li><a href="../../community/support.html">Support</a></li>
      <li><a href="http://caml.inria.fr/mantis/my_view_page.php" target="_blank">Bug Tracker</a></li>
    </ul>
  </div>
</div>

<div class="column">
  <div class="entry">
    <h1>Website</h1>
    <ul>
      <li><a href="https://github.com/ocaml/ocaml.org/tree/master/site/learn/tutorials/basics.ja.md" target="_blank">Edit this page</a></li>
      <li><a href="https://github.com/ocaml/ocaml.org/issues" target="_blank">Website Issues</a></li>
      <li><a href="../../about.html">About This Site</a></li>
    <li><a href="https://github.com/ocaml/ocaml.org/" target="_blank">Find Us on GitHub</a></li>
      <li><a href="../../contributors.html">Credits</a></li>
    </ul>
  </div>
</div>

      </div>
    </footer>
    
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.1/js/bootstrap.min.js" type="text/javascript"></script>

     

  </body>
</html>
